import { __assign, __awaiter, __generator, __read, __spreadArray } from "tslib";
import { parseQueryString } from "@aws-sdk/querystring-parser";
import { getCanonicalQuery, getPayloadHash, moveHeadersToQuery, normalizeCredentialsProvider, normalizeRegionProvider, prepareRequest, } from "@aws-sdk/signature-v4";
import { auth as crtAuth, http as crtHttp, io as crtIO } from "aws-crt";
import { MAX_PRESIGNED_TTL, SHA256_HEADER } from "./constants";
import { deleteHeader } from "./headerUtil";
/* private function to convert sdk Http request to crt Http request */
function sdkHttpRequest2crtHttpRequest(sdkRequest) {
    /* Remove the x-amz-content-sha256 header, if exists */
    deleteHeader(SHA256_HEADER, sdkRequest.headers);
    var headersArray = Object.entries(sdkRequest.headers);
    var crtHttpHeaders = new crtHttp.HttpHeaders(headersArray);
    var queryString = getCanonicalQuery(sdkRequest);
    /**
     * Not converting the body to the crtRequest. For now, it's better to get the payload Hash from SDK.
     * The body value will be set from config.
     */
    return new crtHttp.HttpRequest(sdkRequest.method, sdkRequest.path + "?" + queryString, crtHttpHeaders);
}
/**
 * Based aws-crt, with the same API as signing the request from SignatureV4, compatible with request Signer from SDK.
 * The difference between them is CrtSignerV4 only supports signing/presigning the request. The behavior of two signers
 * are slightly different, includes the case of headers name after signing and the CrtSignerV4 does NOT support overwrite
 * the internal check against (x-amzn-trace-id, user-agent), which will always be skipped.
 * Most importantly, CrtSignerV4 supports Signature V4 Asymmetric.
 *
 * Note: aws-crt that supports SigV4A is still a private repo https://github.com/awslabs/aws-crt-nodejs-staging/tree/sigv4a-binding
 */
var CrtSignerV4 = /** @class */ (function () {
    function CrtSignerV4(_a) {
        var credentials = _a.credentials, region = _a.region, service = _a.service, sha256 = _a.sha256, _b = _a.applyChecksum, applyChecksum = _b === void 0 ? true : _b, _c = _a.uriEscapePath, uriEscapePath = _c === void 0 ? true : _c, _d = _a.signingAlgorithm, signingAlgorithm = _d === void 0 ? crtAuth.AwsSigningAlgorithm.SigV4 : _d;
        this.service = service;
        this.sha256 = sha256;
        this.uriEscapePath = uriEscapePath;
        this.signingAlgorithm = signingAlgorithm;
        this.applyChecksum = applyChecksum;
        this.regionProvider = normalizeRegionProvider(region);
        this.credentialProvider = normalizeCredentialsProvider(credentials);
        crtIO.enable_logging(crtIO.LogLevel.ERROR);
    }
    CrtSignerV4.prototype.options2crtConfigure = function (_a, viaHeader, payloadHash, expiresIn) {
        var _b = _a === void 0 ? {} : _a, _c = _b.signingDate, signingDate = _c === void 0 ? new Date() : _c, signableHeaders = _b.signableHeaders, unsignableHeaders = _b.unsignableHeaders, signingRegion = _b.signingRegion, signingService = _b.signingService;
        return __awaiter(this, void 0, void 0, function () {
            var credentials, region, _d, service, headersUnsignable;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0: return [4 /*yield*/, this.credentialProvider()];
                    case 1:
                        credentials = _e.sent();
                        if (!(signingRegion !== null && signingRegion !== void 0)) return [3 /*break*/, 2];
                        _d = signingRegion;
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, this.regionProvider()];
                    case 3:
                        _d = (_e.sent());
                        _e.label = 4;
                    case 4:
                        region = _d;
                        service = signingService !== null && signingService !== void 0 ? signingService : this.service;
                        if ((signableHeaders === null || signableHeaders === void 0 ? void 0 : signableHeaders.has("x-amzn-trace-id")) || (signableHeaders === null || signableHeaders === void 0 ? void 0 : signableHeaders.has("user-agent"))) {
                            throw new Error("internal check (x-amzn-trace-id, user-agent) is not supported to be included to sign with CRT.");
                        }
                        headersUnsignable = getHeadersUnsignable(unsignableHeaders, signableHeaders);
                        return [2 /*return*/, {
                                algorithm: this.signingAlgorithm,
                                signature_type: viaHeader
                                    ? crtAuth.AwsSignatureType.HttpRequestViaHeaders
                                    : crtAuth.AwsSignatureType.HttpRequestViaQueryParams,
                                provider: sdk2crtCredentialsProvider(credentials),
                                region: region,
                                service: service,
                                date: new Date(signingDate),
                                header_blacklist: headersUnsignable,
                                use_double_uri_encode: this.uriEscapePath,
                                /* Always set the body value by the result from SDK */
                                signed_body_value: payloadHash,
                                signed_body_header: this.applyChecksum && viaHeader
                                    ? crtAuth.AwsSignedBodyHeaderType.XAmzContentSha256
                                    : crtAuth.AwsSignedBodyHeaderType.None,
                                expiration_in_seconds: expiresIn,
                            }];
                }
            });
        });
    };
    CrtSignerV4.prototype.presign = function (originalRequest, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var request, crtSignedRequest, _a, _b, _c, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (options.expiresIn && options.expiresIn > MAX_PRESIGNED_TTL) {
                            return [2 /*return*/, Promise.reject("Signature version 4 presigned URLs" + " must have an expiration date less than one week in" + " the future")];
                        }
                        request = moveHeadersToQuery(prepareRequest(originalRequest));
                        _a = this.signRequest;
                        _b = [request];
                        _c = this.options2crtConfigure;
                        _d = [options,
                            false /* viaHeader */];
                        return [4 /*yield*/, getPayloadHash(originalRequest, this.sha256)];
                    case 1: return [4 /*yield*/, _c.apply(this, _d.concat([_e.sent(), options.expiresIn ? options.expiresIn : 3600]))];
                    case 2: return [4 /*yield*/, _a.apply(this, _b.concat([_e.sent()]))];
                    case 3:
                        crtSignedRequest = _e.sent();
                        request.query = this.getQueryParam(crtSignedRequest.path);
                        return [2 /*return*/, request];
                }
            });
        });
    };
    CrtSignerV4.prototype.sign = function (toSign, options) {
        return __awaiter(this, void 0, void 0, function () {
            var request, crtSignedRequest, _a, _b, _c, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        request = prepareRequest(toSign);
                        _a = this.signRequest;
                        _b = [request];
                        _c = this.options2crtConfigure;
                        _d = [options, true /* viaHeader */];
                        return [4 /*yield*/, getPayloadHash(toSign, this.sha256)];
                    case 1: return [4 /*yield*/, _c.apply(this, _d.concat([_e.sent()]))];
                    case 2: return [4 /*yield*/, _a.apply(this, _b.concat([_e.sent()]))];
                    case 3:
                        crtSignedRequest = _e.sent();
                        request.headers = crtSignedRequest.headers._flatten().reduce(function (acc, _a) {
                            var _b;
                            var _c = __read(_a, 2), key = _c[0], value = _c[1];
                            return (__assign(__assign({}, acc), (_b = {}, _b[key] = value, _b)));
                        }, {});
                        return [2 /*return*/, request];
                }
            });
        });
    };
    /* Get the query parameters from crtPath */
    CrtSignerV4.prototype.getQueryParam = function (crtPath) {
        var start = crtPath.search(/\?/);
        var startHash = crtPath.search(/\#/);
        var end = startHash == -1 ? undefined : startHash;
        var queryParam = {};
        if (start == -1) {
            return queryParam;
        }
        var queryString = crtPath.slice(start + 1, end);
        return parseQueryString(queryString);
    };
    CrtSignerV4.prototype.signRequest = function (requestToSign, crtConfig) {
        return __awaiter(this, void 0, void 0, function () {
            var request, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        request = sdkHttpRequest2crtHttpRequest(requestToSign);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, crtAuth.aws_sign_request(request, crtConfig)];
                    case 2: return [2 /*return*/, _a.sent()];
                    case 3:
                        error_1 = _a.sent();
                        throw new Error(error_1);
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Test-only API used for cross-library signing verification tests. Verify sign.
     *
     * Verifies:
     *  (1) The canonical request generated during sigv4a signing of the request matches what is passed in
     *  (2) The signature passed in is a valid ECDSA signature of the hashed string-to-sign derived from the
     *  canonical request
     *
     * @param request The original request used for signing
     * @param signature the actual signature computed from a previous signing of the signable
     * @param expectedCanonicalRequest expected result when building the canonical request
     * @param eccPubKeyX the x coordinate of the public part of the ecc key to verify the signature
     * @param eccPubKeyY the y coordinate of the public part of the ecc key to verify the signature
     * @param options the RequestSigningArguments used for signing
     *
     * @return True, if the verification succeed. Otherwise, false.
     */
    CrtSignerV4.prototype.verifySigv4aSigning = function (request, signature, expectedCanonicalRequest, eccPubKeyX, eccPubKeyY, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var sdkRequest, crtRequest, payloadHash, crtConfig;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        sdkRequest = prepareRequest(request);
                        crtRequest = sdkHttpRequest2crtHttpRequest(sdkRequest);
                        return [4 /*yield*/, getPayloadHash(request, this.sha256)];
                    case 1:
                        payloadHash = _a.sent();
                        return [4 /*yield*/, this.options2crtConfigure(options, true /* viaHeader */, payloadHash)];
                    case 2:
                        crtConfig = _a.sent();
                        return [2 /*return*/, crtAuth.aws_verify_sigv4a_signing(crtRequest, crtConfig, expectedCanonicalRequest, signature, eccPubKeyX, eccPubKeyY)];
                }
            });
        });
    };
    /* Verify presign */
    CrtSignerV4.prototype.verifySigv4aPreSigning = function (request, signature, expectedCanonicalRequest, eccPubKeyX, eccPubKeyY, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var sdkRequest, crtRequest, crtConfig, _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (typeof signature != "string") {
                            return [2 /*return*/, false];
                        }
                        sdkRequest = prepareRequest(request);
                        crtRequest = sdkHttpRequest2crtHttpRequest(sdkRequest);
                        _a = this.options2crtConfigure;
                        _b = [options,
                            false /* viaHeader */];
                        return [4 /*yield*/, getPayloadHash(request, this.sha256)];
                    case 1: return [4 /*yield*/, _a.apply(this, _b.concat([_c.sent(), options.expiresIn ? options.expiresIn : 3600]))];
                    case 2:
                        crtConfig = _c.sent();
                        return [2 /*return*/, crtAuth.aws_verify_sigv4a_signing(crtRequest, crtConfig, expectedCanonicalRequest, signature, eccPubKeyX, eccPubKeyY)];
                }
            });
        });
    };
    return CrtSignerV4;
}());
export { CrtSignerV4 };
function sdk2crtCredentialsProvider(credentials) {
    return crtAuth.AwsCredentialsProvider.newStatic(credentials.accessKeyId, credentials.secretAccessKey, credentials.sessionToken);
}
function getHeadersUnsignable(unsignableHeaders, signableHeaders) {
    if (!unsignableHeaders) {
        return [];
    }
    if (!signableHeaders) {
        return __spreadArray([], __read(unsignableHeaders), false);
    }
    var result = new Set(__spreadArray([], __read(unsignableHeaders), false));
    for (var it_1 = signableHeaders.values(), val = null; (val = it_1.next().value);) {
        if (result.has(val)) {
            result.delete(val);
        }
    }
    return __spreadArray([], __read(result), false);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ3J0U2lnbmVyVjQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvQ3J0U2lnbmVyVjQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQy9ELE9BQU8sRUFDTCxpQkFBaUIsRUFDakIsY0FBYyxFQUNkLGtCQUFrQixFQUNsQiw0QkFBNEIsRUFDNUIsdUJBQXVCLEVBQ3ZCLGNBQWMsR0FHZixNQUFNLHVCQUF1QixDQUFDO0FBVy9CLE9BQU8sRUFBRSxJQUFJLElBQUksT0FBTyxFQUFFLElBQUksSUFBSSxPQUFPLEVBQUUsRUFBRSxJQUFJLEtBQUssRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUV4RSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsYUFBYSxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQy9ELE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFJNUMsc0VBQXNFO0FBQ3RFLFNBQVMsNkJBQTZCLENBQUMsVUFBdUI7SUFDNUQsdURBQXVEO0lBQ3ZELFlBQVksQ0FBQyxhQUFhLEVBQUUsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ2hELElBQU0sWUFBWSxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3hELElBQU0sY0FBYyxHQUFHLElBQUksT0FBTyxDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUM3RCxJQUFNLFdBQVcsR0FBRyxpQkFBaUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUVsRDs7O09BR0c7SUFDSCxPQUFPLElBQUksT0FBTyxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFLFVBQVUsQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLFdBQVcsRUFBRSxjQUFjLENBQUMsQ0FBQztBQUN6RyxDQUFDO0FBV0Q7Ozs7Ozs7O0dBUUc7QUFDSDtJQVNFLHFCQUFZLEVB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S0FDL0I7SUFDRCxJQUFNLE1BQU0sR0FBRyxJQUFJLEdBQUcsMEJBQUssaUJBQWlCLFVBQUUsQ0FBQztJQUMvQyxLQUFLLElBQUksSUFBRSxHQUFHLGVBQWUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxHQUFHLEdBQUcsSUFBSSxFQUFFLENBQUMsR0FBRyxHQUFHLElBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBSTtRQUM3RSxJQUFJLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDbkIsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUNwQjtLQUNGO0lBQ0QsZ0NBQVcsTUFBTSxVQUFFO0FBQ3JCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZVF1ZXJ5U3RyaW5nIH0gZnJvbSBcIkBhd3Mtc2RrL3F1ZXJ5c3RyaW5nLXBhcnNlclwiO1xuaW1wb3J0IHtcbiAgZ2V0Q2Fub25pY2FsUXVlcnksXG4gIGdldFBheWxvYWRIYXNoLFxuICBtb3ZlSGVhZGVyc1RvUXVlcnksXG4gIG5vcm1hbGl6ZUNyZWRlbnRpYWxzUHJvdmlkZXIsXG4gIG5vcm1hbGl6ZVJlZ2lvblByb3ZpZGVyLFxuICBwcmVwYXJlUmVxdWVzdCxcbiAgU2lnbmF0dXJlVjRDcnlwdG9Jbml0LFxuICBTaWduYXR1cmVWNEluaXQsXG59IGZyb20gXCJAYXdzLXNkay9zaWduYXR1cmUtdjRcIjtcbmltcG9ydCB7XG4gIENyZWRlbnRpYWxzLFxuICBIdHRwUmVxdWVzdCxcbiAgUHJvdmlkZXIsXG4gIFF1ZXJ5UGFyYW1ldGVyQmFnLFxuICBSZXF1ZXN0UHJlc2lnbmVyLFxuICBSZXF1ZXN0UHJlc2lnbmluZ0FyZ3VtZW50cyxcbiAgUmVxdWVzdFNpZ25lcixcbiAgUmVxdWVzdFNpZ25pbmdBcmd1bWVudHMsXG59IGZyb20gXCJAYXdzLXNkay90eXBlc1wiO1xuaW1wb3J0IHsgYXV0aCBhcyBjcnRBdXRoLCBodHRwIGFzIGNydEh0dHAsIGlvIGFzIGNydElPIH0gZnJvbSBcImF3cy1jcnRcIjtcblxuaW1wb3J0IHsgTUFYX1BSRVNJR05FRF9UVEwsIFNIQTI1Nl9IRUFERVIgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IGRlbGV0ZUhlYWRlciB9IGZyb20gXCIuL2hlYWRlclV0aWxcIjtcblxuZXhwb3J0IHR5cGUgQXdzU2lnbmluZ0FsZ29yaXRobSA9IGNydEF1dGguQXdzU2lnbmluZ0FsZ29yaXRobTtcblxuLyogcHJpdmF0ZSBmdW5jdGlvbiB0byBjb252ZXJ0IHNkayBIdHRwIHJlcXVlc3QgdG8gY3J0IEh0dHAgcmVxdWVzdCAqL1xuZnVuY3Rpb24gc2RrSHR0cFJlcXVlc3QyY3J0SHR0cFJlcXVlc3Qoc2RrUmVxdWVzdDogSHR0cFJlcXVlc3QpOiBjcnRIdHRwLkh0dHBSZXF1ZXN0IHtcbiAgLyogUmVtb3ZlIHRoZSB4LWFtei1jb250ZW50LXNoYTI1NiBoZWFkZXIsIGlmIGV4aXN0cyAqL1xuICBkZWxldGVIZWFkZXIoU0hBMjU2X0hFQURFUiwgc2RrUmVxdWVzdC5oZWFkZXJzKTtcbiAgY29uc3QgaGVhZGVyc0FycmF5ID0gT2JqZWN0LmVudHJpZXMoc2RrUmVxdWVzdC5oZWFkZXJzKTtcbiAgY29uc3QgY3J0SHR0cEhlYWRlcnMgPSBuZXcgY3J0SHR0cC5IdHRwSGVhZGVycyhoZWFkZXJzQXJyYXkpO1xuICBjb25zdCBxdWVyeVN0cmluZyA9IGdldENhbm9uaWNhbFF1ZXJ5KHNka1JlcXVlc3QpO1xuXG4gIC8qKlxuICAgKiBOb3QgY29udmVydGluZyB0aGUgYm9keSB0byB0aGUgY3J0UmVxdWVzdC4gRm9yIG5vdywgaXQncyBiZXR0ZXIgdG8gZ2V0IHRoZSBwYXlsb2FkIEhhc2ggZnJvbSBTREsuXG4gICAqIFRoZSBib2R5IHZhbHVlIHdpbGwgYmUgc2V0IGZyb20gY29uZmlnLlxuICAgKi9cbiAgcmV0dXJuIG5ldyBjcnRIdHRwLkh0dHBSZXF1ZXN0KHNka1JlcXVlc3QubWV0aG9kLCBzZGtSZXF1ZXN0LnBhdGggKyBcIj9cIiArIHF1ZXJ5U3RyaW5nLCBjcnRIdHRwSGVhZGVycyk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3J0U2lnbmVyVjRJbml0IGV4dGVuZHMgU2lnbmF0dXJlVjRJbml0IHtcbiAgLyoqXG4gICAqIFRoZSBBbGdvcml0aG0gdXNlZCBmb3IgdGhlIHNpZ25lci4gSW5jbHVkZXM6IFNpZ1Y0LCBTaWdWNEFzeW1tZXRyaWMuXG4gICAqXG4gICAqIEBkZWZhdWx0IFtTaWdWNF1cbiAgICovXG4gIHNpZ25pbmdBbGdvcml0aG0/OiBBd3NTaWduaW5nQWxnb3JpdGhtO1xufVxuXG4vKipcbiAqIEJhc2VkIGF3cy1jcnQsIHdpdGggdGhlIHNhbWUgQVBJIGFzIHNpZ25pbmcgdGhlIHJlcXVlc3QgZnJvbSBTaWduYXR1cmVWNCwgY29tcGF0aWJsZSB3aXRoIHJlcXVlc3QgU2lnbmVyIGZyb20gU0RLLlxuICogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGVtIGlzIENydFNpZ25lclY0IG9ubHkgc3VwcG9ydHMgc2lnbmluZy9wcmVzaWduaW5nIHRoZSByZXF1ZXN0LiBUaGUgYmVoYXZpb3Igb2YgdHdvIHNpZ25lcnNcbiAqIGFyZSBzbGlnaHRseSBkaWZmZXJlbnQsIGluY2x1ZGVzIHRoZSBjYXNlIG9mIGhlYWRlcnMgbmFtZSBhZnRlciBzaWduaW5nIGFuZCB0aGUgQ3J0U2lnbmVyVjQgZG9lcyBOT1Qgc3VwcG9ydCBvdmVyd3JpdGVcbiAqIHRoZSBpbnRlcm5hbCBjaGVjayBhZ2FpbnN0ICh4LWFtem4tdHJhY2UtaWQsIHVzZXItYWdlbnQpLCB3aGljaCB3aWxsIGFsd2F5cyBiZSBza2lwcGVkLlxuICogTW9zdCBpbXBvcnRhbnRseSwgQ3J0U2lnbmVyVjQgc3VwcG9ydHMgU2lnbmF0dXJlIFY0IEFzeW1tZXRyaWMuXG4gKlxuICogTm90ZTogYXdzLWNydCB0aGF0IHN1cHBvcnRzIFNpZ1Y0QSBpcyBzdGlsbCBhIHByaXZhdGUgcmVwbyBodHRwczovL2dpdGh1Yi5jb20vYXdzbGFicy9hd3MtY3J0LW5vZGVqcy1zdGFnaW5nL3RyZWUvc2lndjRhLWJpbmRpbmdcbiAqL1xuZXhwb3J0IGNsYXNzIENydFNpZ25lclY0IGltcGxlbWVudHMgUmVxdWVzdFByZXNpZ25lciwgUmVxdWVzdFNpZ25lciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgc2VydmljZTogc3RyaW5nO1xuICBwcml2YXRlIHJlYWRvbmx5IHJlZ2lvblByb3ZpZGVyOiBQcm92aWRlcjxzdHJpbmc+O1xuICBwcml2YXRlIHJlYWRvbmx5IGNyZWRlbnRpYWxQcm92aWRlcjogUHJvdmlkZXI8Q3JlZGVudGlhbHM+O1xuICBwcml2YXRlIHJlYWRvbmx5IHNoYTI1NjogYW55O1xuICBwcml2YXRlIHJlYWRvbmx5IHVyaUVzY2FwZVBhdGg6IGJvb2xlYW47XG4gIHByaXZhdGUgcmVhZG9ubHkgYXBwbHlDaGVja3N1bTogYm9vbGVhbjtcbiAgcHJpdmF0ZSByZWFkb25seSBzaWduaW5nQWxnb3JpdGhtOiBBd3NTaWduaW5nQWxnb3JpdGhtO1xuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjcmVkZW50aWFscyxcbiAgICByZWdpb24sXG4gICAgc2VydmljZSxcbiAgICBzaGEyNTYsXG4gICAgYXBwbHlDaGVja3N1bSA9IHRydWUsXG4gICAgdXJpRXNjYXBlUGF0aCA9IHRydWUsXG4gICAgc2lnbmluZ0FsZ29yaXRobSA9IGNydEF1dGguQXdzU2lnbmluZ0FsZ29yaXRobS5TaWdWNCxcbiAgfTogQ3J0U2lnbmVyVjRJbml0ICYgU2lnbmF0dXJlVjRDcnlwdG9Jbml0KSB7XG4gICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICB0aGlzLnNoYTI1NiA9IHNoYTI1NjtcbiAgICB0aGlzLnVyaUVzY2FwZVBhdGggPSB1cmlFc2NhcGVQYXRoO1xuICAgIHRoaXMuc2lnbmluZ0FsZ29yaXRobSA9IHNpZ25pbmdBbGdvcml0aG07XG4gICAgdGhpcy5hcHBseUNoZWNrc3VtID0gYXBwbHlDaGVja3N1bTtcbiAgICB0aGlzLnJlZ2lvblByb3ZpZGVyID0gbm9ybWFsaXplUmVnaW9uUHJvdmlkZXIocmVnaW9uKTtcbiAgICB0aGlzLmNyZWRlbnRpYWxQcm92aWRlciA9IG5vcm1hbGl6ZUNyZWRlbnRpYWxzUHJvdmlkZXIoY3JlZGVudGlhbHMpO1xuICAgIGNydElPLmVuYWJsZV9sb2dnaW5nKGNydElPLkxvZ0xldmVsLkVSUk9SKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgb3B0aW9uczJjcnRDb25maWd1cmUoXG4gICAge1xuICAgICAgc2lnbmluZ0RhdGUgPSBuZXcgRGF0ZSgpLFxuICAgICAgc2lnbmFibGVIZWFkZXJzLFxuICAgICAgdW5zaWduYWJsZUhlYWRlcnMsXG4gICAgICBzaWduaW5nUmVnaW9uLFxuICAgICAgc2lnbmluZ1NlcnZpY2UsXG4gICAgfTogUmVxdWVzdFNpZ25pbmdBcmd1bWVudHMgfCBSZXF1ZXN0UHJlc2lnbmluZ0FyZ3VtZW50cyB8IHVuZGVmaW5lZCA9IHt9LFxuICAgIHZpYUhlYWRlcjogQm9vbGVhbixcbiAgICBwYXlsb2FkSGFzaDogc3RyaW5nLFxuICAgIGV4cGlyZXNJbj86IG51bWJlclxuICApOiBQcm9taXNlPGNydEF1dGguQXdzU2lnbmluZ0NvbmZpZz4ge1xuICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gYXdhaXQgdGhpcy5jcmVkZW50aWFsUHJvdmlkZXIoKTtcbiAgICBjb25zdCByZWdpb24gPSBzaWduaW5nUmVnaW9uID8/IChhd2FpdCB0aGlzLnJlZ2lvblByb3ZpZGVyKCkpO1xuICAgIGNvbnN0IHNlcnZpY2UgPSBzaWduaW5nU2VydmljZSA/PyB0aGlzLnNlcnZpY2U7XG4gICAgaWYgKHNpZ25hYmxlSGVhZGVycz8uaGFzKFwieC1hbXpuLXRyYWNlLWlkXCIpIHx8IHNpZ25hYmxlSGVhZGVycz8uaGFzKFwidXNlci1hZ2VudFwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW50ZXJuYWwgY2hlY2sgKHgtYW16bi10cmFjZS1pZCwgdXNlci1hZ2VudCkgaXMgbm90IHN1cHBvcnRlZCB0byBiZSBpbmNsdWRlZCB0byBzaWduIHdpdGggQ1JULlwiKTtcbiAgICB9XG4gICAgY29uc3QgaGVhZGVyc1Vuc2lnbmFibGUgPSBnZXRIZWFkZXJzVW5zaWduYWJsZSh1bnNpZ25hYmxlSGVhZGVycywgc2lnbmFibGVIZWFkZXJzKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWxnb3JpdGhtOiB0aGlzLnNpZ25pbmdBbGdvcml0aG0sXG4gICAgICBzaWduYXR1cmVfdHlwZTogdmlhSGVhZGVyXG4gICAgICAgID8gY3J0QXV0aC5Bd3NTaWduYXR1cmVUeXBlLkh0dHBSZXF1ZXN0VmlhSGVhZGVyc1xuICAgICAgICA6IGNydEF1dGguQXdzU2lnbmF0dXJlVHlwZS5IdHRwUmVxdWVzdFZpYVF1ZXJ5UGFyYW1zLFxuICAgICAgcHJvdmlkZXI6IHNkazJjcnRDcmVkZW50aWFsc1Byb3ZpZGVyKGNyZWRlbnRpYWxzKSxcbiAgICAgIHJlZ2lvbjogcmVnaW9uLFxuICAgICAgc2VydmljZTogc2VydmljZSxcbiAgICAgIGRhdGU6IG5ldyBEYXRlKHNpZ25pbmdEYXRlKSxcbiAgICAgIGhlYWRlcl9ibGFja2xpc3Q6IGhlYWRlcnNVbnNpZ25hYmxlLFxuICAgICAgdXNlX2RvdWJsZV91cmlfZW5jb2RlOiB0aGlzLnVyaUVzY2FwZVBhdGgsXG4gICAgICAvKiBBbHdheXMgc2V0IHRoZSBib2R5IHZhbHVlIGJ5IHRoZSByZXN1bHQgZnJvbSBTREsgKi9cbiAgICAgIHNpZ25lZF9ib2R5X3ZhbHVlOiBwYXlsb2FkSGFzaCxcbiAgICAgIHNpZ25lZF9ib2R5X2hlYWRlcjpcbiAgICAgICAgdGhpcy5hcHBseUNoZWNrc3VtICYmIHZpYUhlYWRlclxuICAgICAgICAgID8gY3J0QXV0aC5Bd3NTaWduZWRCb2R5SGVhZGVyVHlwZS5YQW16Q29udGVudFNoYTI1NlxuICAgICAgICAgIDogY3J0QXV0aC5Bd3NTaWduZWRCb2R5SGVhZGVyVHlwZS5Ob25lLFxuICAgICAgZXhwaXJhdGlvbl9pbl9zZWNvbmRzOiBleHBpcmVzSW4sXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBwcmVzaWduKG9yaWdpbmFsUmVxdWVzdDogSHR0cFJlcXVlc3QsIG9wdGlvbnM6IFJlcXVlc3RQcmVzaWduaW5nQXJndW1lbnRzID0ge30pOiBQcm9taXNlPEh0dHBSZXF1ZXN0PiB7XG4gICAgaWYgKG9wdGlvbnMuZXhwaXJlc0luICYmIG9wdGlvbnMuZXhwaXJlc0luID4gTUFYX1BSRVNJR05FRF9UVEwpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgXCJTaWduYXR1cmUgdmVyc2lvbiA0IHByZXNpZ25lZCBVUkxzXCIgKyBcIiBtdXN0IGhhdmUgYW4gZXhwaXJhdGlvbiBkYXRlIGxlc3MgdGhhbiBvbmUgd2VlayBpblwiICsgXCIgdGhlIGZ1dHVyZVwiXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0ID0gbW92ZUhlYWRlcnNUb1F1ZXJ5KHByZXBhcmVSZXF1ZXN0KG9yaWdpbmFsUmVxdWVzdCkpO1xuXG4gICAgY29uc3QgY3J0U2lnbmVkUmVxdWVzdCA9IGF3YWl0IHRoaXMuc2lnblJlcXVlc3QoXG4gICAgICByZXF1ZXN0LFxuICAgICAgYXdhaXQgdGhpcy5vcHRpb25zMmNydENvbmZpZ3VyZShcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZmFsc2UgLyogdmlhSGVhZGVyICovLFxuICAgICAgICBhd2FpdCBnZXRQYXlsb2FkSGFzaChvcmlnaW5hbFJlcXVlc3QsIHRoaXMuc2hhMjU2KSxcbiAgICAgICAgb3B0aW9ucy5leHBpcmVzSW4gPyBvcHRpb25zLmV4cGlyZXNJbiA6IDM2MDBcbiAgICAgIClcbiAgICApO1xuICAgIHJlcXVlc3QucXVlcnkgPSB0aGlzLmdldFF1ZXJ5UGFyYW0oY3J0U2lnbmVkUmVxdWVzdC5wYXRoKTtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzaWduKHRvU2lnbjogSHR0cFJlcXVlc3QsIG9wdGlvbnM/OiBSZXF1ZXN0U2lnbmluZ0FyZ3VtZW50cyk6IFByb21pc2U8SHR0cFJlcXVlc3Q+IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gcHJlcGFyZVJlcXVlc3QodG9TaWduKTtcbiAgICBjb25zdCBjcnRTaWduZWRSZXF1ZXN0ID0gYXdhaXQgdGhpcy5zaWduUmVxdWVzdChcbiAgICAgIHJlcXVlc3QsXG4gICAgICBhd2FpdCB0aGlzLm9wdGlvbnMyY3J0Q29uZmlndXJlKG9wdGlvbnMsIHRydWUgLyogdmlhSGVhZGVyICovLCBhd2FpdCBnZXRQYXlsb2FkSGFzaCh0b1NpZ24sIHRoaXMuc2hhMjU2KSlcbiAgICApO1xuICAgIHJlcXVlc3QuaGVhZGVycyA9IGNydFNpZ25lZFJlcXVlc3QuaGVhZGVycy5fZmxhdHRlbigpLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+ICh7IC4uLmFjYywgW2tleV06IHZhbHVlIH0pLCB7fSk7XG4gICAgcmV0dXJuIHJlcXVlc3Q7XG4gIH1cblxuICAvKiBHZXQgdGhlIHF1ZXJ5IHBhcmFtZXRlcnMgZnJvbSBjcnRQYXRoICovXG4gIHByaXZhdGUgZ2V0UXVlcnlQYXJhbShjcnRQYXRoOiBzdHJpbmcpOiBRdWVyeVBhcmFtZXRlckJhZyB7XG4gICAgY29uc3Qgc3RhcnQgPSBjcnRQYXRoLnNlYXJjaCgvXFw/Lyk7XG4gICAgY29uc3Qgc3RhcnRIYXNoID0gY3J0UGF0aC5zZWFyY2goL1xcIy8pO1xuICAgIGNvbnN0IGVuZCA9IHN0YXJ0SGFzaCA9PSAtMSA/IHVuZGVmaW5lZCA6IHN0YXJ0SGFzaDtcbiAgICBjb25zdCBxdWVyeVBhcmFtID0ge30gYXMgUXVlcnlQYXJhbWV0ZXJCYWc7XG4gICAgaWYgKHN0YXJ0ID09IC0xKSB7XG4gICAgICByZXR1cm4gcXVlcnlQYXJhbTtcbiAgICB9XG4gICAgY29uc3QgcXVlcnlTdHJpbmcgPSBjcnRQYXRoLnNsaWNlKHN0YXJ0ICsgMSwgZW5kKTtcbiAgICByZXR1cm4gcGFyc2VRdWVyeVN0cmluZyhxdWVyeVN0cmluZyk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHNpZ25SZXF1ZXN0KFxuICAgIHJlcXVlc3RUb1NpZ246IEh0dHBSZXF1ZXN0LFxuICAgIGNydENvbmZpZzogY3J0QXV0aC5Bd3NTaWduaW5nQ29uZmlnXG4gICk6IFByb21pc2U8Y3J0SHR0cC5IdHRwUmVxdWVzdD4ge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBzZGtIdHRwUmVxdWVzdDJjcnRIdHRwUmVxdWVzdChyZXF1ZXN0VG9TaWduKTtcbiAgICAvLyBpZiAocmVxdWVzdFRvU2lnbi5oZWFkZXJzW1RPS0VOX0hFQURFUl0pXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBjcnRBdXRoLmF3c19zaWduX3JlcXVlc3QocmVxdWVzdCwgY3J0Q29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGVzdC1vbmx5IEFQSSB1c2VkIGZvciBjcm9zcy1saWJyYXJ5IHNpZ25pbmcgdmVyaWZpY2F0aW9uIHRlc3RzLiBWZXJpZnkgc2lnbi5cbiAgICpcbiAgICogVmVyaWZpZXM6XG4gICAqICAoMSkgVGhlIGNhbm9uaWNhbCByZXF1ZXN0IGdlbmVyYXRlZCBkdXJpbmcgc2lndjRhIHNpZ25pbmcgb2YgdGhlIHJlcXVlc3QgbWF0Y2hlcyB3aGF0IGlzIHBhc3NlZCBpblxuICAgKiAgKDIpIFRoZSBzaWduYXR1cmUgcGFzc2VkIGluIGlzIGEgdmFsaWQgRUNEU0Egc2lnbmF0dXJlIG9mIHRoZSBoYXNoZWQgc3RyaW5nLXRvLXNpZ24gZGVyaXZlZCBmcm9tIHRoZVxuICAgKiAgY2Fub25pY2FsIHJlcXVlc3RcbiAgICpcbiAgICogQHBhcmFtIHJlcXVlc3QgVGhlIG9yaWdpbmFsIHJlcXVlc3QgdXNlZCBmb3Igc2lnbmluZ1xuICAgKiBAcGFyYW0gc2lnbmF0dXJlIHRoZSBhY3R1YWwgc2lnbmF0dXJlIGNvbXB1dGVkIGZyb20gYSBwcmV2aW91cyBzaWduaW5nIG9mIHRoZSBzaWduYWJsZVxuICAgKiBAcGFyYW0gZXhwZWN0ZWRDYW5vbmljYWxSZXF1ZXN0IGV4cGVjdGVkIHJlc3VsdCB3aGVuIGJ1aWxkaW5nIHRoZSBjYW5vbmljYWwgcmVxdWVzdFxuICAgKiBAcGFyYW0gZWNjUHViS2V5WCB0aGUgeCBjb29yZGluYXRlIG9mIHRoZSBwdWJsaWMgcGFydCBvZiB0aGUgZWNjIGtleSB0byB2ZXJpZnkgdGhlIHNpZ25hdHVyZVxuICAgKiBAcGFyYW0gZWNjUHViS2V5WSB0aGUgeSBjb29yZGluYXRlIG9mIHRoZSBwdWJsaWMgcGFydCBvZiB0aGUgZWNjIGtleSB0byB2ZXJpZnkgdGhlIHNpZ25hdHVyZVxuICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgUmVxdWVzdFNpZ25pbmdBcmd1bWVudHMgdXNlZCBmb3Igc2lnbmluZ1xuICAgKlxuICAgKiBAcmV0dXJuIFRydWUsIGlmIHRoZSB2ZXJpZmljYXRpb24gc3VjY2VlZC4gT3RoZXJ3aXNlLCBmYWxzZS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyB2ZXJpZnlTaWd2NGFTaWduaW5nKFxuICAgIHJlcXVlc3Q6IEh0dHBSZXF1ZXN0LFxuICAgIHNpZ25hdHVyZTogc3RyaW5nLFxuICAgIGV4cGVjdGVkQ2Fub25pY2FsUmVxdWVzdDogc3RyaW5nLFxuICAgIGVjY1B1YktleVg6IHN0cmluZyxcbiAgICBlY2NQdWJLZXlZOiBzdHJpbmcsXG4gICAgb3B0aW9uczogUmVxdWVzdFNpZ25pbmdBcmd1bWVudHMgPSB7fVxuICApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCBzZGtSZXF1ZXN0ID0gcHJlcGFyZVJlcXVlc3QocmVxdWVzdCk7XG4gICAgY29uc3QgY3J0UmVxdWVzdCA9IHNka0h0dHBSZXF1ZXN0MmNydEh0dHBSZXF1ZXN0KHNka1JlcXVlc3QpO1xuICAgIGNvbnN0IHBheWxvYWRIYXNoID0gYXdhaXQgZ2V0UGF5bG9hZEhhc2gocmVxdWVzdCwgdGhpcy5zaGEyNTYpO1xuICAgIGNvbnN0IGNydENvbmZpZyA9IGF3YWl0IHRoaXMub3B0aW9uczJjcnRDb25maWd1cmUob3B0aW9ucywgdHJ1ZSAvKiB2aWFIZWFkZXIgKi8sIHBheWxvYWRIYXNoKTtcbiAgICByZXR1cm4gY3J0QXV0aC5hd3NfdmVyaWZ5X3NpZ3Y0YV9zaWduaW5nKFxuICAgICAgY3J0UmVxdWVzdCxcbiAgICAgIGNydENvbmZpZyxcbiAgICAgIGV4cGVjdGVkQ2Fub25pY2FsUmVxdWVzdCxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIGVjY1B1YktleVgsXG4gICAgICBlY2NQdWJLZXlZXG4gICAgKTtcbiAgfVxuXG4gIC8qIFZlcmlmeSBwcmVzaWduICovXG4gIHB1YmxpYyBhc3luYyB2ZXJpZnlTaWd2NGFQcmVTaWduaW5nKFxuICAgIHJlcXVlc3Q6IEh0dHBSZXF1ZXN0LFxuICAgIHNpZ25hdHVyZTogc3RyaW5nIHwgQXJyYXk8c3RyaW5nPiB8IG51bGwsXG4gICAgZXhwZWN0ZWRDYW5vbmljYWxSZXF1ZXN0OiBzdHJpbmcsXG4gICAgZWNjUHViS2V5WDogc3RyaW5nLFxuICAgIGVjY1B1YktleVk6IHN0cmluZyxcbiAgICBvcHRpb25zOiBSZXF1ZXN0UHJlc2lnbmluZ0FyZ3VtZW50cyA9IHt9XG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGlmICh0eXBlb2Ygc2lnbmF0dXJlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc2RrUmVxdWVzdCA9IHByZXBhcmVSZXF1ZXN0KHJlcXVlc3QpO1xuICAgIGNvbnN0IGNydFJlcXVlc3QgPSBzZGtIdHRwUmVxdWVzdDJjcnRIdHRwUmVxdWVzdChzZGtSZXF1ZXN0KTtcbiAgICBjb25zdCBjcnRDb25maWcgPSBhd2FpdCB0aGlzLm9wdGlvbnMyY3J0Q29uZmlndXJlKFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGZhbHNlIC8qIHZpYUhlYWRlciAqLyxcbiAgICAgIGF3YWl0IGdldFBheWxvYWRIYXNoKHJlcXVlc3QsIHRoaXMuc2hhMjU2KSxcbiAgICAgIG9wdGlvbnMuZXhwaXJlc0luID8gb3B0aW9ucy5leHBpcmVzSW4gOiAzNjAwXG4gICAgKTtcbiAgICByZXR1cm4gY3J0QXV0aC5hd3NfdmVyaWZ5X3NpZ3Y0YV9zaWduaW5nKFxuICAgICAgY3J0UmVxdWVzdCxcbiAgICAgIGNydENvbmZpZyxcbiAgICAgIGV4cGVjdGVkQ2Fub25pY2FsUmVxdWVzdCxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIGVjY1B1YktleVgsXG4gICAgICBlY2NQdWJLZXlZXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZGsyY3J0Q3JlZGVudGlhbHNQcm92aWRlcihjcmVkZW50aWFsczogQ3JlZGVudGlhbHMpOiBjcnRBdXRoLkF3c0NyZWRlbnRpYWxzUHJvdmlkZXIge1xuICByZXR1cm4gY3J0QXV0aC5Bd3NDcmVkZW50aWFsc1Byb3ZpZGVyLm5ld1N0YXRpYyhcbiAgICBjcmVkZW50aWFscy5hY2Nlc3NLZXlJZCxcbiAgICBjcmVkZW50aWFscy5zZWNyZXRBY2Nlc3NLZXksXG4gICAgY3JlZGVudGlhbHMuc2Vzc2lvblRva2VuXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldEhlYWRlcnNVbnNpZ25hYmxlKHVuc2lnbmFibGVIZWFkZXJzPzogU2V0PHN0cmluZz4sIHNpZ25hYmxlSGVhZGVycz86IFNldDxzdHJpbmc+KTogc3RyaW5nW10ge1xuICBpZiAoIXVuc2lnbmFibGVIZWFkZXJzKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmICghc2lnbmFibGVIZWFkZXJzKSB7XG4gICAgcmV0dXJuIFsuLi51bnNpZ25hYmxlSGVhZGVyc107XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gbmV3IFNldChbLi4udW5zaWduYWJsZUhlYWRlcnNdKTtcbiAgZm9yIChsZXQgaXQgPSBzaWduYWJsZUhlYWRlcnMudmFsdWVzKCksIHZhbCA9IG51bGw7ICh2YWwgPSBpdC5uZXh0KCkudmFsdWUpOyApIHtcbiAgICBpZiAocmVzdWx0Lmhhcyh2YWwpKSB7XG4gICAgICByZXN1bHQuZGVsZXRlKHZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBbLi4ucmVzdWx0XTtcbn1cbiJdfQ==