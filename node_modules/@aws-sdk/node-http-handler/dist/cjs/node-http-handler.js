"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeHttpHandler = void 0;
const protocol_http_1 = require("@aws-sdk/protocol-http");
const querystring_builder_1 = require("@aws-sdk/querystring-builder");
const http_1 = require("http");
const https_1 = require("https");
const constants_1 = require("./constants");
const get_transformed_headers_1 = require("./get-transformed-headers");
const set_connection_timeout_1 = require("./set-connection-timeout");
const set_socket_timeout_1 = require("./set-socket-timeout");
const write_request_body_1 = require("./write-request-body");
class NodeHttpHandler {
    constructor({ connectionTimeout, socketTimeout, httpAgent, httpsAgent } = {}) {
        // Node http handler is hard-coded to http/1.1: https://github.com/nodejs/node/blob/ff5664b83b89c55e4ab5d5f60068fb457f1f5872/lib/_http_server.js#L286
        this.metadata = { handlerProtocol: "http/1.1" };
        this.connectionTimeout = connectionTimeout;
        this.socketTimeout = socketTimeout;
        const keepAlive = true;
        const maxSockets = 50;
        this.httpAgent = httpAgent || new http_1.Agent({ keepAlive, maxSockets });
        this.httpsAgent = httpsAgent || new https_1.Agent({ keepAlive, maxSockets });
    }
    destroy() {
        this.httpAgent.destroy();
        this.httpsAgent.destroy();
    }
    handle(request, { abortSignal } = {}) {
        return new Promise((resolve, reject) => {
            // if the request was already aborted, prevent doing extra work
            if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            // determine which http(s) client to use
            const isSSL = request.protocol === "https:";
            const queryString = (0, querystring_builder_1.buildQueryString)(request.query || {});
            const nodeHttpsOptions = {
                headers: request.headers,
                host: request.hostname,
                method: request.method,
                path: queryString ? `${request.path}?${queryString}` : request.path,
                port: request.port,
                agent: isSSL ? this.httpsAgent : this.httpAgent,
            };
            // create the http request
            const requestFunc = isSSL ? https_1.request : http_1.request;
            const req = requestFunc(nodeHttpsOptions, (res) => {
                const httpResponse = new protocol_http_1.HttpResponse({
                    statusCode: res.statusCode || -1,
                    headers: (0, get_transformed_headers_1.getTransformedHeaders)(res.headers),
                    body: res,
                });
                resolve({ response: httpResponse });
            });
            req.on("error", (err) => {
                if (constants_1.NODEJS_TIMEOUT_ERROR_CODES.includes(err.code)) {
                    reject(Object.assign(err, { name: "TimeoutError" }));
                }
                else {
                    reject(err);
                }
            });
            // wire-up any timeout logic
            (0, set_connection_timeout_1.setConnectionTimeout)(req, reject, this.connectionTimeout);
            (0, set_socket_timeout_1.setSocketTimeout)(req, reject, this.socketTimeout);
            // wire-up abort logic
            if (abortSignal) {
                abortSignal.onabort = () => {
                    // ensure request is destroyed
                    req.abort();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
            }
            (0, write_request_body_1.writeRequestBody)(req, request);
        });
    }
}
exports.NodeHttpHandler = NodeHttpHandler;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZS1odHRwLWhhbmRsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvbm9kZS1odHRwLWhhbmRsZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsMERBQWdGO0FBQ2hGLHNFQUFnRTtBQUVoRSwrQkFBNEQ7QUFDNUQsaUNBQStFO0FBRS9FLDJDQUF5RDtBQUN6RCx1RUFBa0U7QUFDbEUscUVBQWdFO0FBQ2hFLDZEQUF3RDtBQUN4RCw2REFBd0Q7QUFzQnhELE1BQWEsZUFBZTtJQVExQixZQUFZLEVBQUUsaUJBQWlCLEVBQUUsYUFBYSxFQUFFLFNBQVMsRUFBRSxVQUFVLEtBQTZCLEVBQUU7UUFIcEcscUpBQXFKO1FBQ3JJLGFBQVEsR0FBRyxFQUFFLGVBQWUsRUFBRSxVQUFVLEVBQUUsQ0FBQztRQUd6RCxJQUFJLENBQUMsaUJBQWlCLEdBQUcsaUJBQWlCLENBQUM7UUFDM0MsSUFBSSxDQUFDLGFBQWEsR0FBRyxhQUFhLENBQUM7UUFDbkMsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDO1FBQ3ZCLE1BQU0sVUFBVSxHQUFHLEVBQUUsQ0FBQztRQUN0QixJQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsSUFBSSxJQUFJLFlBQU0sQ0FBQyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDO1FBQ3BFLElBQUksQ0FBQyxVQUFVLEdBQUcsVUFBVSxJQUFJLElBQUksYUFBTyxDQUFDLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxDQUFDLENBQUM7SUFDekUsQ0FBQztJQUVELE9BQU87UUFDTCxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ3pCLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDNUIsQ0FBQztJQUVELE1BQU0sQ0FBQyxPQUFvQixFQUFFLEVBQUUsV0FBVyxLQUF5QixFQUFFO1FBQ25FLE9BQU8sSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsTUFB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QUcsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUNqQyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRjtBQWpGRCwwQ0FpRkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIdHRwSGFuZGxlciwgSHR0cFJlcXVlc3QsIEh0dHBSZXNwb25zZSB9IGZyb20gXCJAYXdzLXNkay9wcm90b2NvbC1odHRwXCI7XG5pbXBvcnQgeyBidWlsZFF1ZXJ5U3RyaW5nIH0gZnJvbSBcIkBhd3Mtc2RrL3F1ZXJ5c3RyaW5nLWJ1aWxkZXJcIjtcbmltcG9ydCB7IEh0dHBIYW5kbGVyT3B0aW9ucyB9IGZyb20gXCJAYXdzLXNkay90eXBlc1wiO1xuaW1wb3J0IHsgQWdlbnQgYXMgaEFnZW50LCByZXF1ZXN0IGFzIGhSZXF1ZXN0IH0gZnJvbSBcImh0dHBcIjtcbmltcG9ydCB7IEFnZW50IGFzIGhzQWdlbnQsIHJlcXVlc3QgYXMgaHNSZXF1ZXN0LCBSZXF1ZXN0T3B0aW9ucyB9IGZyb20gXCJodHRwc1wiO1xuXG5pbXBvcnQgeyBOT0RFSlNfVElNRU9VVF9FUlJPUl9DT0RFUyB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgZ2V0VHJhbnNmb3JtZWRIZWFkZXJzIH0gZnJvbSBcIi4vZ2V0LXRyYW5zZm9ybWVkLWhlYWRlcnNcIjtcbmltcG9ydCB7IHNldENvbm5lY3Rpb25UaW1lb3V0IH0gZnJvbSBcIi4vc2V0LWNvbm5lY3Rpb24tdGltZW91dFwiO1xuaW1wb3J0IHsgc2V0U29ja2V0VGltZW91dCB9IGZyb20gXCIuL3NldC1zb2NrZXQtdGltZW91dFwiO1xuaW1wb3J0IHsgd3JpdGVSZXF1ZXN0Qm9keSB9IGZyb20gXCIuL3dyaXRlLXJlcXVlc3QtYm9keVwiO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGh0dHAgb3B0aW9ucyB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gYSBub2RlIGh0dHAgY2xpZW50LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5vZGVIdHRwSGFuZGxlck9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIG1heGltdW0gdGltZSBpbiBtaWxsaXNlY29uZHMgdGhhdCB0aGUgY29ubmVjdGlvbiBwaGFzZSBvZiBhIHJlcXVlc3RcbiAgICogbWF5IHRha2UgYmVmb3JlIHRoZSBjb25uZWN0aW9uIGF0dGVtcHQgaXMgYWJhbmRvbmVkLlxuICAgKi9cbiAgY29ubmVjdGlvblRpbWVvdXQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRoYXQgYSBzb2NrZXQgbWF5IHJlbWFpbiBpZGxlIGJlZm9yZSBpdFxuICAgKiBpcyBjbG9zZWQuXG4gICAqL1xuICBzb2NrZXRUaW1lb3V0PzogbnVtYmVyO1xuXG4gIGh0dHBBZ2VudD86IGhBZ2VudDtcbiAgaHR0cHNBZ2VudD86IGhzQWdlbnQ7XG59XG5cbmV4cG9ydCBjbGFzcyBOb2RlSHR0cEhhbmRsZXIgaW1wbGVtZW50cyBIdHRwSGFuZGxlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgaHR0cEFnZW50OiBoQWdlbnQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgaHR0cHNBZ2VudDogaHNBZ2VudDtcbiAgcHJpdmF0ZSByZWFkb25seSBjb25uZWN0aW9uVGltZW91dD86IG51bWJlcjtcbiAgcHJpdmF0ZSByZWFkb25seSBzb2NrZXRUaW1lb3V0PzogbnVtYmVyO1xuICAvLyBOb2RlIGh0dHAgaGFuZGxlciBpcyBoYXJkLWNvZGVkIHRvIGh0dHAvMS4xOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9mZjU2NjRiODNiODljNTVlNGFiNWQ1ZjYwMDY4ZmI0NTdmMWY1ODcyL2xpYi9faHR0cF9zZXJ2ZXIuanMjTDI4NlxuICBwdWJsaWMgcmVhZG9ubHkgbWV0YWRhdGEgPSB7IGhhbmRsZXJQcm90b2NvbDogXCJodHRwLzEuMVwiIH07XG5cbiAgY29uc3RydWN0b3IoeyBjb25uZWN0aW9uVGltZW91dCwgc29ja2V0VGltZW91dCwgaHR0cEFnZW50LCBodHRwc0FnZW50IH06IE5vZGVIdHRwSGFuZGxlck9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuY29ubmVjdGlvblRpbWVvdXQgPSBjb25uZWN0aW9uVGltZW91dDtcbiAgICB0aGlzLnNvY2tldFRpbWVvdXQgPSBzb2NrZXRUaW1lb3V0O1xuICAgIGNvbnN0IGtlZXBBbGl2ZSA9IHRydWU7XG4gICAgY29uc3QgbWF4U29ja2V0cyA9IDUwO1xuICAgIHRoaXMuaHR0cEFnZW50ID0gaHR0cEFnZW50IHx8IG5ldyBoQWdlbnQoeyBrZWVwQWxpdmUsIG1heFNvY2tldHMgfSk7XG4gICAgdGhpcy5odHRwc0FnZW50ID0gaHR0cHNBZ2VudCB8fCBuZXcgaHNBZ2VudCh7IGtlZXBBbGl2ZSwgbWF4U29ja2V0cyB9KTtcbiAgfVxuXG4gIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5odHRwQWdlbnQuZGVzdHJveSgpO1xuICAgIHRoaXMuaHR0cHNBZ2VudC5kZXN0cm95KCk7XG4gIH1cblxuICBoYW5kbGUocmVxdWVzdDogSHR0cFJlcXVlc3QsIHsgYWJvcnRTaWduYWwgfTogSHR0cEhhbmRsZXJPcHRpb25zID0ge30pOiBQcm9taXNlPHsgcmVzcG9uc2U6IEh0dHBSZXNwb25zZSB9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8vIGlmIHRoZSByZXF1ZXN0IHdhcyBhbHJlYWR5IGFib3J0ZWQsIHByZXZlbnQgZG9pbmcgZXh0cmEgd29ya1xuICAgICAgaWYgKGFib3J0U2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgIGNvbnN0IGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoXCJSZXF1ZXN0IGFib3J0ZWRcIik7XG4gICAgICAgIGFib3J0RXJyb3IubmFtZSA9IFwiQWJvcnRFcnJvclwiO1xuICAgICAgICByZWplY3QoYWJvcnRFcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIGh0dHAocykgY2xpZW50IHRvIHVzZVxuICAgICAgY29uc3QgaXNTU0wgPSByZXF1ZXN0LnByb3RvY29sID09PSBcImh0dHBzOlwiO1xuICAgICAgY29uc3QgcXVlcnlTdHJpbmcgPSBidWlsZFF1ZXJ5U3RyaW5nKHJlcXVlc3QucXVlcnkgfHwge30pO1xuICAgICAgY29uc3Qgbm9kZUh0dHBzT3B0aW9uczogUmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcbiAgICAgICAgaG9zdDogcmVxdWVzdC5ob3N0bmFtZSxcbiAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgcGF0aDogcXVlcnlTdHJpbmcgPyBgJHtyZXF1ZXN0LnBhdGh9PyR7cXVlcnlTdHJpbmd9YCA6IHJlcXVlc3QucGF0aCxcbiAgICAgICAgcG9ydDogcmVxdWVzdC5wb3J0LFxuICAgICAgICBhZ2VudDogaXNTU0wgPyB0aGlzLmh0dHBzQWdlbnQgOiB0aGlzLmh0dHBBZ2VudCxcbiAgICAgIH07XG5cbiAgICAgIC8vIGNyZWF0ZSB0aGUgaHR0cCByZXF1ZXN0XG4gICAgICBjb25zdCByZXF1ZXN0RnVuYyA9IGlzU1NMID8gaHNSZXF1ZXN0IDogaFJlcXVlc3Q7XG4gICAgICBjb25zdCByZXEgPSByZXF1ZXN0RnVuYyhub2RlSHR0cHNPcHRpb25zLCAocmVzKSA9PiB7XG4gICAgICAgIGNvbnN0IGh0dHBSZXNwb25zZSA9IG5ldyBIdHRwUmVzcG9uc2Uoe1xuICAgICAgICAgIHN0YXR1c0NvZGU6IHJlcy5zdGF0dXNDb2RlIHx8IC0xLFxuICAgICAgICAgIGhlYWRlcnM6IGdldFRyYW5zZm9ybWVkSGVhZGVycyhyZXMuaGVhZGVycyksXG4gICAgICAgICAgYm9keTogcmVzLFxuICAgICAgICB9KTtcbiAgICAgICAgcmVzb2x2ZSh7IHJlc3BvbnNlOiBodHRwUmVzcG9uc2UgfSk7XG4gICAgICB9KTtcblxuICAgICAgcmVxLm9uKFwiZXJyb3JcIiwgKGVycjogRXJyb3IpID0+IHtcbiAgICAgICAgaWYgKE5PREVKU19USU1FT1VUX0VSUk9SX0NPREVTLmluY2x1ZGVzKChlcnIgYXMgYW55KS5jb2RlKSkge1xuICAgICAgICAgIHJlamVjdChPYmplY3QuYXNzaWduKGVyciwgeyBuYW1lOiBcIlRpbWVvdXRFcnJvclwiIH0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIHdpcmUtdXAgYW55IHRpbWVvdXQgbG9naWNcbiAgICAgIHNldENvbm5lY3Rpb25UaW1lb3V0KHJlcSwgcmVqZWN0LCB0aGlzLmNvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICAgIHNldFNvY2tldFRpbWVvdXQocmVxLCByZWplY3QsIHRoaXMuc29ja2V0VGltZW91dCk7XG5cbiAgICAgIC8vIHdpcmUtdXAgYWJvcnQgbG9naWNcbiAgICAgIGlmIChhYm9ydFNpZ25hbCkge1xuICAgICAgICBhYm9ydFNpZ25hbC5vbmFib3J0ID0gKCkgPT4ge1xuICAgICAgICAgIC8vIGVuc3VyZSByZXF1ZXN0IGlzIGRlc3Ryb3llZFxuICAgICAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgICAgIGNvbnN0IGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoXCJSZXF1ZXN0IGFib3J0ZWRcIik7XG4gICAgICAgICAgYWJvcnRFcnJvci5uYW1lID0gXCJBYm9ydEVycm9yXCI7XG4gICAgICAgICAgcmVqZWN0KGFib3J0RXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB3cml0ZVJlcXVlc3RCb2R5KHJlcSwgcmVxdWVzdCk7XG4gICAgfSk7XG4gIH1cbn1cbiJdfQ==