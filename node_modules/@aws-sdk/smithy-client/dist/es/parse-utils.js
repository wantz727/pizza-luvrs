/**
 * Give an input string, strictly parses a boolean value.
 *
 * @param value The boolean string to parse.
 * @returns true for "true", false for "false", otherwise an error is thrown.
 */
export var parseBoolean = function (value) {
    switch (value) {
        case "true":
            return true;
        case "false":
            return false;
        default:
            throw new Error("Unable to parse boolean value \"" + value + "\"");
    }
};
/*
 * Asserts a value is a boolean and returns it.
 *
 * @param value A value that is expected to be a boolean.
 * @returns The value if it's a boolean, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
export var expectBoolean = function (value) {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "boolean") {
        return value;
    }
    throw new TypeError("Expected boolean, got " + typeof value);
};
/**
 * Asserts a value is a number and returns it.
 *
 * @param value A value that is expected to be a number.
 * @returns The value if it's a number, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
export var expectNumber = function (value) {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "number") {
        return value;
    }
    throw new TypeError("Expected number, got " + typeof value);
};
var MAX_FLOAT = Math.ceil(Math.pow(2, 127) * (2 - Math.pow(2, -23)));
/**
 * Asserts a value is a 32-bit float and returns it.
 *
 * @param value A value that is expected to be a 32-bit float.
 * @returns The value if it's a float, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
export var expectFloat32 = function (value) {
    var expected = expectNumber(value);
    if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
        // IEEE-754 is an imperfect representation for floats. Consider the simple
        // value `0.1`. The representation in a 32-bit float would look like:
        //
        // 0 01111011 10011001100110011001101
        // Actual value: 0.100000001490116119384765625
        //
        // Note the repeating pattern of `1001` in the fraction part. The 64-bit
        // representation is similar:
        //
        // 0 01111111011 1001100110011001100110011001100110011001100110011010
        // Actual value: 0.100000000000000005551115123126
        //
        // So even for what we consider simple numbers, the representation differs
        // between the two formats. And it's non-obvious how one might look at the
        // 64-bit value (which is how JS represents numbers) and determine if it
        // can be represented reasonably in the 32-bit form. Primarily because you
        // can't know whether the intent was to represent `0.1` or the actual
        // value in memory. But even if you have both the decimal value and the
        // double value, that still doesn't communicate the intended precision.
        //
        // So rather than attempting to divine the intent of the caller, we instead
        // do some simple bounds checking to make sure the value is passingly
        // representable in a 32-bit float. It's not perfect, but it's good enough.
        // Perfect, even if possible to achieve, would likely be too costly to
        // be worth it.
        //
        // The maximum value of a 32-bit float. Since the 64-bit representation
        // could be more or less, we just round it up to the nearest whole number.
        // This further reduces our ability to be certain of the value, but it's
        // an acceptable tradeoff.
        //
        // Compare against the absolute value to simplify things.
        if (Math.abs(expected) > MAX_FLOAT) {
            throw new TypeError("Expected 32-bit float, got " + value);
        }
    }
    return expected;
};
/**
 * Asserts a value is an integer and returns it.
 *
 * @param value A value that is expected to be an integer.
 * @returns The value if it's an integer, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
export var expectLong = function (value) {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (Number.isInteger(value) && !Number.isNaN(value)) {
        return value;
    }
    throw new TypeError("Expected integer, got " + typeof value);
};
/**
 * @deprecated Use expectLong
 */
export var expectInt = expectLong;
/**
 * Asserts a value is a 32-bit integer and returns it.
 *
 * @param value A value that is expected to be an integer.
 * @returns The value if it's an integer, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
export var expectInt32 = function (value) { return expectSizedInt(value, 32); };
/**
 * Asserts a value is a 16-bit integer and returns it.
 *
 * @param value A value that is expected to be an integer.
 * @returns The value if it's an integer, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
export var expectShort = function (value) { return expectSizedInt(value, 16); };
/**
 * Asserts a value is an 8-bit integer and returns it.
 *
 * @param value A value that is expected to be an integer.
 * @returns The value if it's an integer, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
export var expectByte = function (value) { return expectSizedInt(value, 8); };
var expectSizedInt = function (value, size) {
    var expected = expectLong(value);
    if (expected !== undefined && castInt(expected, size) !== expected) {
        throw new TypeError("Expected " + size + "-bit integer, got " + value);
    }
    return expected;
};
var castInt = function (value, size) {
    switch (size) {
        case 32:
            return Int32Array.of(value)[0];
        case 16:
            return Int16Array.of(value)[0];
        case 8:
            return Int8Array.of(value)[0];
    }
};
/**
 * Asserts a value is not null or undefined and returns it, or throws an error.
 *
 * @param value A value that is expected to be defined
 * @param location The location where we're expecting to find a defined object (optional)
 * @returns The value if it's not undefined, otherwise throws an error
 */
export var expectNonNull = function (value, location) {
    if (value === null || value === undefined) {
        if (location) {
            throw new TypeError("Expected a non-null value for " + location);
        }
        throw new TypeError("Expected a non-null value");
    }
    return value;
};
/**
 * Asserts a value is an JSON-like object and returns it. This is expected to be used
 * with values parsed from JSON (arrays, objects, numbers, strings, booleans).
 *
 * @param value A value that is expected to be an object
 * @returns The value if it's an object, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
export var expectObject = function (value) {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "object" && !Array.isArray(value)) {
        return value;
    }
    throw new TypeError("Expected object, got " + typeof value);
};
/**
 * Asserts a value is a string and returns it.
 *
 * @param value A value that is expected to be a string.
 * @returns The value if it's a string, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
export var expectString = function (value) {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        return value;
    }
    throw new TypeError("Expected string, got " + typeof value);
};
/**
 * Parses a value into a double. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by the standard
 * parseFloat with one exception: NaN may only be explicitly set as the string
 * "NaN", any implicit Nan values will result in an error being thrown. If any
 * other type is provided, an exception will be thrown.
 *
 * @param value A number or string representation of a double.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
export var strictParseDouble = function (value) {
    if (typeof value == "string") {
        return expectNumber(parseNumber(value));
    }
    return expectNumber(value);
};
/**
 * @deprecated Use strictParseDouble
 */
export var strictParseFloat = strictParseDouble;
/**
 * Parses a value into a float. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by the standard
 * parseFloat with one exception: NaN may only be explicitly set as the string
 * "NaN", any implicit Nan values will result in an error being thrown. If any
 * other type is provided, an exception will be thrown.
 *
 * @param value A number or string representation of a float.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
export var strictParseFloat32 = function (value) {
    if (typeof value == "string") {
        return expectFloat32(parseNumber(value));
    }
    return expectFloat32(value);
};
// This regex matches JSON-style numbers. In short:
// * The integral may start with a negative sign, but not a positive one
// * No leading 0 on the integral unless it's immediately followed by a '.'
// * Exponent indicated by a case-insensitive 'E' optionally followed by a
//   positive/negative sign and some number of digits.
// It also matches both positive and negative infinity as well and explicit NaN.
var NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
var parseNumber = function (value) {
    var matches = value.match(NUMBER_REGEX);
    if (matches === null || matches[0].length !== value.length) {
        throw new TypeError("Expected real number, got implicit NaN");
    }
    return parseFloat(value);
};
/**
 * Asserts a value is a number and returns it. If the value is a string
 * representation of a non-numeric number type (NaN, Infinity, -Infinity),
 * the value will be parsed. Any other string value will result in an exception
 * being thrown. Null or undefined will be returned as undefined. Any other
 * type will result in an exception being thrown.
 *
 * @param value A number or string representation of a non-numeric float.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
export var limitedParseDouble = function (value) {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return expectNumber(value);
};
/**
 * @deprecated Use limitedParseDouble
 */
export var handleFloat = limitedParseDouble;
/**
 * @deprecated Use limitedParseDouble
 */
export var limitedParseFloat = limitedParseDouble;
/**
 * Asserts a value is a 32-bit float and returns it. If the value is a string
 * representation of a non-numeric number type (NaN, Infinity, -Infinity),
 * the value will be parsed. Any other string value will result in an exception
 * being thrown. Null or undefined will be returned as undefined. Any other
 * type will result in an exception being thrown.
 *
 * @param value A number or string representation of a non-numeric float.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
export var limitedParseFloat32 = function (value) {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return expectFloat32(value);
};
var parseFloatString = function (value) {
    switch (value) {
        case "NaN":
            return NaN;
        case "Infinity":
            return Infinity;
        case "-Infinity":
            return -Infinity;
        default:
            throw new Error("Unable to parse float value: " + value);
    }
};
/**
 * Parses a value into an integer. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by parseFloat
 * and the result will be asserted to be an integer. If the parsed value is not
 * an integer, or the raw value is any type other than a string or number, an
 * exception will be thrown.
 *
 * @param value A number or string representation of an integer.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
export var strictParseLong = function (value) {
    if (typeof value === "string") {
        // parseInt can't be used here, because it will silently discard any
        // existing decimals. We want to instead throw an error if there are any.
        return expectLong(parseNumber(value));
    }
    return expectLong(value);
};
/**
 * @deprecated Use strictParseLong
 */
export var strictParseInt = strictParseLong;
/**
 * Parses a value into a 32-bit integer. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by parseFloat
 * and the result will be asserted to be an integer. If the parsed value is not
 * an integer, or the raw value is any type other than a string or number, an
 * exception will be thrown.
 *
 * @param value A number or string representation of a 32-bit integer.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
export var strictParseInt32 = function (value) {
    if (typeof value === "string") {
        // parseInt can't be used here, because it will silently discard any
        // existing decimals. We want to instead throw an error if there are any.
        return expectInt32(parseNumber(value));
    }
    return expectInt32(value);
};
/**
 * Parses a value into a 16-bit integer. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by parseFloat
 * and the result will be asserted to be an integer. If the parsed value is not
 * an integer, or the raw value is any type other than a string or number, an
 * exception will be thrown.
 *
 * @param value A number or string representation of a 16-bit integer.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
export var strictParseShort = function (value) {
    if (typeof value === "string") {
        // parseInt can't be used here, because it will silently discard any
        // existing decimals. We want to instead throw an error if there are any.
        return expectShort(parseNumber(value));
    }
    return expectShort(value);
};
/**
 * Parses a value into an 8-bit integer. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by parseFloat
 * and the result will be asserted to be an integer. If the parsed value is not
 * an integer, or the raw value is any type other than a string or number, an
 * exception will be thrown.
 *
 * @param value A number or string representation of an 8-bit integer.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
export var strictParseByte = function (value) {
    if (typeof value === "string") {
        // parseInt can't be used here, because it will silently discard any
        // existing decimals. We want to instead throw an error if there are any.
        return expectByte(parseNumber(value));
    }
    return expectByte(value);
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2UtdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcGFyc2UtdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0dBS0c7QUFDSCxNQUFNLENBQUMsSUFBTSxZQUFZLEdBQUcsVUFBQyxLQUFhO0lBQ3hDLFFBQVEsS0FBSyxFQUFFO1FBQ2IsS0FBSyxNQUFNO1lBQ1QsT0FBTyxJQUFJLENBQUM7UUFDZCxLQUFLLE9BQU87WUFDVixPQUFPLEtBQUssQ0FBQztRQUNmO1lBQ0UsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQ0FBa0MsS0FBSyxPQUFHLENBQUMsQ0FBQztLQUMvRDtBQUNILENBQUMsQ0FBQztBQUVGOzs7Ozs7R0FNRztBQUNILE1BQU0sQ0FBQyxJQUFNLGFBQWEsR0FBRyxVQUFDLEtBQVU7SUFDdEMsSUFBSSxLQUFLLEtBQUssSUFBSSxJQUFJLEtBQUssS0FBSyxTQUFTLEVBQUU7UUFDekMsT0FBTyxTQUFTLENBQUM7S0FDbEI7SUFDRCxJQUFJLE9BQU8sS0FBSyxLQUFLLFNBQVMsRUFBRTtRQUM5QixPQUFPLEtBQUssQ0FBQztLQUNkO0lBQ0QsTUFBTSxJQUFJLFNBQVMsQ0FBQywyQkFBeUIsT0FBTyxLQUFPLENBQUMsQ0FBQztBQUMvRCxDQUFDLENBQUM7QUFFRjs7Ozs7O0dBTUc7QUFDSCxNQUFNLENBQUMsSUFBTSxZQUFZLEdBQUcsVUFBQyxLQUFVO0lBQ3JDLElBQUksS0FBSyxLQUFLLElBQUksSUFBSSxLQUFLLEtBQUssU0FBUyxFQUFFO1FBQ3pDLE9BQU8sU0FBUyxDQUFDO0tBQ2xCO0lBQ0QsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7UUFDN0IsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUNELE1BQU0sSUFBSSxTQUFTLENBQUMsMEJBQXdCLE9BQU8sS0FBTyxDQUFDLENBQUM7QUFDOUQsQ0FBQyxDQUFDO0FBRUYsSUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FB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RTtRQUNwRSx5RUFBeUU7UUFDekUsT0FBTyxVQUFVLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7S0FDdkM7SUFDRCxPQUFPLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMzQixDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdpdmUgYW4gaW5wdXQgc3RyaW5nLCBzdHJpY3RseSBwYXJzZXMgYSBib29sZWFuIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgYm9vbGVhbiBzdHJpbmcgdG8gcGFyc2UuXG4gKiBAcmV0dXJucyB0cnVlIGZvciBcInRydWVcIiwgZmFsc2UgZm9yIFwiZmFsc2VcIiwgb3RoZXJ3aXNlIGFuIGVycm9yIGlzIHRocm93bi5cbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlQm9vbGVhbiA9ICh2YWx1ZTogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gIHN3aXRjaCAodmFsdWUpIHtcbiAgICBjYXNlIFwidHJ1ZVwiOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSBcImZhbHNlXCI6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHBhcnNlIGJvb2xlYW4gdmFsdWUgXCIke3ZhbHVlfVwiYCk7XG4gIH1cbn07XG5cbi8qXG4gKiBBc3NlcnRzIGEgdmFsdWUgaXMgYSBib29sZWFuIGFuZCByZXR1cm5zIGl0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBBIHZhbHVlIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgYSBib29sZWFuLlxuICogQHJldHVybnMgVGhlIHZhbHVlIGlmIGl0J3MgYSBib29sZWFuLCB1bmRlZmluZWQgaWYgaXQncyBudWxsL3VuZGVmaW5lZCxcbiAqICAgb3RoZXJ3aXNlIGFuIGVycm9yIGlzIHRocm93bi5cbiAqL1xuZXhwb3J0IGNvbnN0IGV4cGVjdEJvb2xlYW4gPSAodmFsdWU6IGFueSk6IGJvb2xlYW4gfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgZ290ICR7dHlwZW9mIHZhbHVlfWApO1xufTtcblxuLyoqXG4gKiBBc3NlcnRzIGEgdmFsdWUgaXMgYSBudW1iZXIgYW5kIHJldHVybnMgaXQuXG4gKlxuICogQHBhcmFtIHZhbHVlIEEgdmFsdWUgdGhhdCBpcyBleHBlY3RlZCB0byBiZSBhIG51bWJlci5cbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSBpZiBpdCdzIGEgbnVtYmVyLCB1bmRlZmluZWQgaWYgaXQncyBudWxsL3VuZGVmaW5lZCxcbiAqICAgb3RoZXJ3aXNlIGFuIGVycm9yIGlzIHRocm93bi5cbiAqL1xuZXhwb3J0IGNvbnN0IGV4cGVjdE51bWJlciA9ICh2YWx1ZTogYW55KTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgbnVtYmVyLCBnb3QgJHt0eXBlb2YgdmFsdWV9YCk7XG59O1xuXG5jb25zdCBNQVhfRkxPQVQgPSBNYXRoLmNlaWwoMiAqKiAxMjcgKiAoMiAtIDIgKiogLTIzKSk7XG5cbi8qKlxuICogQXNzZXJ0cyBhIHZhbHVlIGlzIGEgMzItYml0IGZsb2F0IGFuZCByZXR1cm5zIGl0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBBIHZhbHVlIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgYSAzMi1iaXQgZmxvYXQuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgaWYgaXQncyBhIGZsb2F0LCB1bmRlZmluZWQgaWYgaXQncyBudWxsL3VuZGVmaW5lZCxcbiAqICAgb3RoZXJ3aXNlIGFuIGVycm9yIGlzIHRocm93bi5cbiAqL1xuZXhwb3J0IGNvbnN0IGV4cGVjdEZsb2F0MzIgPSAodmFsdWU6IGFueSk6IG51bWJlciB8IHVuZGVmaW5lZCA9PiB7XG4gIGNvbnN0IGV4cGVjdGVkID0gZXhwZWN0TnVtYmVyKHZhbHVlKTtcbiAgaWYgKGV4cGVjdGVkICE9PSB1bmRlZmluZWQgJiYgIU51bWJlci5pc05hTihleHBlY3RlZCkgJiYgZXhwZWN0ZWQgIT09IEluZmluaXR5ICYmIGV4cGVjdGVkICE9PSAtSW5maW5pdHkpIHtcbiAgICAvLyBJRUVFLTc1NCBpcyBhbiBpbXBlcmZlY3QgcmVwcmVzZW50YXRpb24gZm9yIGZsb2F0cy4gQ29uc2lkZXIgdGhlIHNpbXBsZVxuICAgIC8vIHZhbHVlIGAwLjFgLiBUaGUgcmVwcmVzZW50YXRpb24gaW4gYSAzMi1iaXQgZmxvYXQgd291bGQgbG9vayBsaWtlOlxuICAgIC8vXG4gICAgLy8gMCAwMTExMTAxMSAxMDAxMTAwMTEwMDExMDAxMTAwMTEwMVxuICAgIC8vIEFjdHVhbCB2YWx1ZTogMC4xMDAwMDAwMDE0OTAxMTYxMTkzODQ3NjU2MjVcbiAgICAvL1xuICAgIC8vIE5vdGUgdGhlIHJlcGVhdGluZyBwYXR0ZXJuIG9mIGAxMDAxYCBpbiB0aGUgZnJhY3Rpb24gcGFydC4gVGhlIDY0LWJpdFxuICAgIC8vIHJlcHJlc2VudGF0aW9uIGlzIHNpbWlsYXI6XG4gICAgLy9cbiAgICAvLyAwIDAxMTExMTExMDExIDEwMDExMDAxMTAwMTEwMDExMDAxMTAwMTEwMDExMDAxMTAwMTEwMDExMDAxMTAwMTEwMTBcbiAgICAvLyBBY3R1YWwgdmFsdWU6IDAuMTAwMDAwMDAwMDAwMDAwMDA1NTUxMTE1MTIzMTI2XG4gICAgLy9cbiAgICAvLyBTbyBldmVuIGZvciB3aGF0IHdlIGNvbnNpZGVyIHNpbXBsZSBudW1iZXJzLCB0aGUgcmVwcmVzZW50YXRpb24gZGlmZmVyc1xuICAgIC8vIGJldHdlZW4gdGhlIHR3byBmb3JtYXRzLiBBbmQgaXQncyBub24tb2J2aW91cyBob3cgb25lIG1pZ2h0IGxvb2sgYXQgdGhlXG4gICAgLy8gNjQtYml0IHZhbHVlICh3aGljaCBpcyBob3cgSlMgcmVwcmVzZW50cyBudW1iZXJzKSBhbmQgZGV0ZXJtaW5lIGlmIGl0XG4gICAgLy8gY2FuIGJlIHJlcHJlc2VudGVkIHJlYXNvbmFibHkgaW4gdGhlIDMyLWJpdCBmb3JtLiBQcmltYXJpbHkgYmVjYXVzZSB5b3VcbiAgICAvLyBjYW4ndCBrbm93IHdoZXRoZXIgdGhlIGludGVudCB3YXMgdG8gcmVwcmVzZW50IGAwLjFgIG9yIHRoZSBhY3R1YWxcbiAgICAvLyB2YWx1ZSBpbiBtZW1vcnkuIEJ1dCBldmVuIGlmIHlvdSBoYXZlIGJvdGggdGhlIGRlY2ltYWwgdmFsdWUgYW5kIHRoZVxuICAgIC8vIGRvdWJsZSB2YWx1ZSwgdGhhdCBzdGlsbCBkb2Vzbid0IGNvbW11bmljYXRlIHRoZSBpbnRlbmRlZCBwcmVjaXNpb24uXG4gICAgLy9cbiAgICAvLyBTbyByYXRoZXIgdGhhbiBhdHRlbXB0aW5nIHRvIGRpdmluZSB0aGUgaW50ZW50IG9mIHRoZSBjYWxsZXIsIHdlIGluc3RlYWRcbiAgICAvLyBkbyBzb21lIHNpbXBsZSBib3VuZHMgY2hlY2tpbmcgdG8gbWFrZSBzdXJlIHRoZSB2YWx1ZSBpcyBwYXNzaW5nbHlcbiAgICAvLyByZXByZXNlbnRhYmxlIGluIGEgMzItYml0IGZsb2F0LiBJdCdzIG5vdCBwZXJmZWN0LCBidXQgaXQncyBnb29kIGVub3VnaC5cbiAgICAvLyBQZXJmZWN0LCBldmVuIGlmIHBvc3NpYmxlIHRvIGFjaGlldmUsIHdvdWxkIGxpa2VseSBiZSB0b28gY29zdGx5IHRvXG4gICAgLy8gYmUgd29ydGggaXQuXG4gICAgLy9cbiAgICAvLyBUaGUgbWF4aW11bSB2YWx1ZSBvZiBhIDMyLWJpdCBmbG9hdC4gU2luY2UgdGhlIDY0LWJpdCByZXByZXNlbnRhdGlvblxuICAgIC8vIGNvdWxkIGJlIG1vcmUgb3IgbGVzcywgd2UganVzdCByb3VuZCBpdCB1cCB0byB0aGUgbmVhcmVzdCB3aG9sZSBudW1iZXIuXG4gICAgLy8gVGhpcyBmdXJ0aGVyIHJlZHVjZXMgb3VyIGFiaWxpdHkgdG8gYmUgY2VydGFpbiBvZiB0aGUgdmFsdWUsIGJ1dCBpdCdzXG4gICAgLy8gYW4gYWNjZXB0YWJsZSB0cmFkZW9mZi5cbiAgICAvL1xuICAgIC8vIENvbXBhcmUgYWdhaW5zdCB0aGUgYWJzb2x1dGUgdmFsdWUgdG8gc2ltcGxpZnkgdGhpbmdzLlxuICAgIGlmIChNYXRoLmFicyhleHBlY3RlZCkgPiBNQVhfRkxPQVQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIDMyLWJpdCBmbG9hdCwgZ290ICR7dmFsdWV9YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBleHBlY3RlZDtcbn07XG5cbi8qKlxuICogQXNzZXJ0cyBhIHZhbHVlIGlzIGFuIGludGVnZXIgYW5kIHJldHVybnMgaXQuXG4gKlxuICogQHBhcmFtIHZhbHVlIEEgdmFsdWUgdGhhdCBpcyBleHBlY3RlZCB0byBiZSBhbiBpbnRlZ2VyLlxuICogQHJldHVybnMgVGhlIHZhbHVlIGlmIGl0J3MgYW4gaW50ZWdlciwgdW5kZWZpbmVkIGlmIGl0J3MgbnVsbC91bmRlZmluZWQsXG4gKiAgIG90aGVyd2lzZSBhbiBlcnJvciBpcyB0aHJvd24uXG4gKi9cbmV4cG9ydCBjb25zdCBleHBlY3RMb25nID0gKHZhbHVlOiBhbnkpOiBudW1iZXIgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpICYmICFOdW1iZXIuaXNOYU4odmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGludGVnZXIsIGdvdCAke3R5cGVvZiB2YWx1ZX1gKTtcbn07XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGV4cGVjdExvbmdcbiAqL1xuZXhwb3J0IGNvbnN0IGV4cGVjdEludCA9IGV4cGVjdExvbmc7XG5cbi8qKlxuICogQXNzZXJ0cyBhIHZhbHVlIGlzIGEgMzItYml0IGludGVnZXIgYW5kIHJldHVybnMgaXQuXG4gKlxuICogQHBhcmFtIHZhbHVlIEEgdmFsdWUgdGhhdCBpcyBleHBlY3RlZCB0byBiZSBhbiBpbnRlZ2VyLlxuICogQHJldHVybnMgVGhlIHZhbHVlIGlmIGl0J3MgYW4gaW50ZWdlciwgdW5kZWZpbmVkIGlmIGl0J3MgbnVsbC91bmRlZmluZWQsXG4gKiAgIG90aGVyd2lzZSBhbiBlcnJvciBpcyB0aHJvd24uXG4gKi9cbmV4cG9ydCBjb25zdCBleHBlY3RJbnQzMiA9ICh2YWx1ZTogYW55KTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IGV4cGVjdFNpemVkSW50KHZhbHVlLCAzMik7XG5cbi8qKlxuICogQXNzZXJ0cyBhIHZhbHVlIGlzIGEgMTYtYml0IGludGVnZXIgYW5kIHJldHVybnMgaXQuXG4gKlxuICogQHBhcmFtIHZhbHVlIEEgdmFsdWUgdGhhdCBpcyBleHBlY3RlZCB0byBiZSBhbiBpbnRlZ2VyLlxuICogQHJldHVybnMgVGhlIHZhbHVlIGlmIGl0J3MgYW4gaW50ZWdlciwgdW5kZWZpbmVkIGlmIGl0J3MgbnVsbC91bmRlZmluZWQsXG4gKiAgIG90aGVyd2lzZSBhbiBlcnJvciBpcyB0aHJvd24uXG4gKi9cbmV4cG9ydCBjb25zdCBleHBlY3RTaG9ydCA9ICh2YWx1ZTogYW55KTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IGV4cGVjdFNpemVkSW50KHZhbHVlLCAxNik7XG5cbi8qKlxuICogQXNzZXJ0cyBhIHZhbHVlIGlzIGFuIDgtYml0IGludGVnZXIgYW5kIHJldHVybnMgaXQuXG4gKlxuICogQHBhcmFtIHZhbHVlIEEgdmFsdWUgdGhhdCBpcyBleHBlY3RlZCB0byBiZSBhbiBpbnRlZ2VyLlxuICogQHJldHVybnMgVGhlIHZhbHVlIGlmIGl0J3MgYW4gaW50ZWdlciwgdW5kZWZpbmVkIGlmIGl0J3MgbnVsbC91bmRlZmluZWQsXG4gKiAgIG90aGVyd2lzZSBhbiBlcnJvciBpcyB0aHJvd24uXG4gKi9cbmV4cG9ydCBjb25zdCBleHBlY3RCeXRlID0gKHZhbHVlOiBhbnkpOiBudW1iZXIgfCB1bmRlZmluZWQgPT4gZXhwZWN0U2l6ZWRJbnQodmFsdWUsIDgpO1xuXG50eXBlIEludFNpemUgPSAzMiB8IDE2IHwgODtcblxuY29uc3QgZXhwZWN0U2l6ZWRJbnQgPSAodmFsdWU6IGFueSwgc2l6ZTogSW50U2l6ZSk6IG51bWJlciB8IHVuZGVmaW5lZCA9PiB7XG4gIGNvbnN0IGV4cGVjdGVkID0gZXhwZWN0TG9uZyh2YWx1ZSk7XG4gIGlmIChleHBlY3RlZCAhPT0gdW5kZWZpbmVkICYmIGNhc3RJbnQoZXhwZWN0ZWQsIHNpemUpICE9PSBleHBlY3RlZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkICR7c2l6ZX0tYml0IGludGVnZXIsIGdvdCAke3ZhbHVlfWApO1xuICB9XG4gIHJldHVybiBleHBlY3RlZDtcbn07XG5cbmNvbnN0IGNhc3RJbnQgPSAodmFsdWU6IG51bWJlciwgc2l6ZTogSW50U2l6ZSkgPT4ge1xuICBzd2l0Y2ggKHNpemUpIHtcbiAgICBjYXNlIDMyOlxuICAgICAgcmV0dXJuIEludDMyQXJyYXkub2YodmFsdWUpWzBdO1xuICAgIGNhc2UgMTY6XG4gICAgICByZXR1cm4gSW50MTZBcnJheS5vZih2YWx1ZSlbMF07XG4gICAgY2FzZSA4OlxuICAgICAgcmV0dXJuIEludDhBcnJheS5vZih2YWx1ZSlbMF07XG4gIH1cbn07XG5cbi8qKlxuICogQXNzZXJ0cyBhIHZhbHVlIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZCBhbmQgcmV0dXJucyBpdCwgb3IgdGhyb3dzIGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBBIHZhbHVlIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgZGVmaW5lZFxuICogQHBhcmFtIGxvY2F0aW9uIFRoZSBsb2NhdGlvbiB3aGVyZSB3ZSdyZSBleHBlY3RpbmcgdG8gZmluZCBhIGRlZmluZWQgb2JqZWN0IChvcHRpb25hbClcbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSBpZiBpdCdzIG5vdCB1bmRlZmluZWQsIG90aGVyd2lzZSB0aHJvd3MgYW4gZXJyb3JcbiAqL1xuZXhwb3J0IGNvbnN0IGV4cGVjdE5vbk51bGwgPSA8VD4odmFsdWU6IFQgfCBudWxsIHwgdW5kZWZpbmVkLCBsb2NhdGlvbj86IHN0cmluZyk6IFQgPT4ge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgYSBub24tbnVsbCB2YWx1ZSBmb3IgJHtsb2NhdGlvbn1gKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgbm9uLW51bGwgdmFsdWVcIik7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBBc3NlcnRzIGEgdmFsdWUgaXMgYW4gSlNPTi1saWtlIG9iamVjdCBhbmQgcmV0dXJucyBpdC4gVGhpcyBpcyBleHBlY3RlZCB0byBiZSB1c2VkXG4gKiB3aXRoIHZhbHVlcyBwYXJzZWQgZnJvbSBKU09OIChhcnJheXMsIG9iamVjdHMsIG51bWJlcnMsIHN0cmluZ3MsIGJvb2xlYW5zKS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgQSB2YWx1ZSB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGFuIG9iamVjdFxuICogQHJldHVybnMgVGhlIHZhbHVlIGlmIGl0J3MgYW4gb2JqZWN0LCB1bmRlZmluZWQgaWYgaXQncyBudWxsL3VuZGVmaW5lZCxcbiAqICAgb3RoZXJ3aXNlIGFuIGVycm9yIGlzIHRocm93bi5cbiAqL1xuZXhwb3J0IGNvbnN0IGV4cGVjdE9iamVjdCA9ICh2YWx1ZTogYW55KTogeyBba2V5OiBzdHJpbmddOiBhbnkgfSB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBvYmplY3QsIGdvdCAke3R5cGVvZiB2YWx1ZX1gKTtcbn07XG5cbi8qKlxuICogQXNzZXJ0cyBhIHZhbHVlIGlzIGEgc3RyaW5nIGFuZCByZXR1cm5zIGl0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBBIHZhbHVlIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgYSBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgaWYgaXQncyBhIHN0cmluZywgdW5kZWZpbmVkIGlmIGl0J3MgbnVsbC91bmRlZmluZWQsXG4gKiAgIG90aGVyd2lzZSBhbiBlcnJvciBpcyB0aHJvd24uXG4gKi9cbmV4cG9ydCBjb25zdCBleHBlY3RTdHJpbmcgPSAodmFsdWU6IGFueSk6IHN0cmluZyB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHZhbHVlfWApO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYSB2YWx1ZSBpbnRvIGEgZG91YmxlLiBJZiB0aGUgdmFsdWUgaXMgbnVsbCBvciB1bmRlZmluZWQsIHVuZGVmaW5lZFxuICogd2lsbCBiZSByZXR1cm5lZC4gSWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nLCBpdCB3aWxsIGJlIHBhcnNlZCBieSB0aGUgc3RhbmRhcmRcbiAqIHBhcnNlRmxvYXQgd2l0aCBvbmUgZXhjZXB0aW9uOiBOYU4gbWF5IG9ubHkgYmUgZXhwbGljaXRseSBzZXQgYXMgdGhlIHN0cmluZ1xuICogXCJOYU5cIiwgYW55IGltcGxpY2l0IE5hbiB2YWx1ZXMgd2lsbCByZXN1bHQgaW4gYW4gZXJyb3IgYmVpbmcgdGhyb3duLiBJZiBhbnlcbiAqIG90aGVyIHR5cGUgaXMgcHJvdmlkZWQsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgQSBudW1iZXIgb3Igc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgZG91YmxlLlxuICogQHJldHVybnMgVGhlIHZhbHVlIGFzIGEgbnVtYmVyLCBvciB1bmRlZmluZWQgaWYgaXQncyBudWxsL3VuZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmljdFBhcnNlRG91YmxlID0gKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIpOiBudW1iZXIgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZXhwZWN0TnVtYmVyKHBhcnNlTnVtYmVyKHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdE51bWJlcih2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBzdHJpY3RQYXJzZURvdWJsZVxuICovXG5leHBvcnQgY29uc3Qgc3RyaWN0UGFyc2VGbG9hdCA9IHN0cmljdFBhcnNlRG91YmxlO1xuXG4vKipcbiAqIFBhcnNlcyBhIHZhbHVlIGludG8gYSBmbG9hdC4gSWYgdGhlIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkLCB1bmRlZmluZWRcbiAqIHdpbGwgYmUgcmV0dXJuZWQuIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSBwYXJzZWQgYnkgdGhlIHN0YW5kYXJkXG4gKiBwYXJzZUZsb2F0IHdpdGggb25lIGV4Y2VwdGlvbjogTmFOIG1heSBvbmx5IGJlIGV4cGxpY2l0bHkgc2V0IGFzIHRoZSBzdHJpbmdcbiAqIFwiTmFOXCIsIGFueSBpbXBsaWNpdCBOYW4gdmFsdWVzIHdpbGwgcmVzdWx0IGluIGFuIGVycm9yIGJlaW5nIHRocm93bi4gSWYgYW55XG4gKiBvdGhlciB0eXBlIGlzIHByb3ZpZGVkLCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKlxuICogQHBhcmFtIHZhbHVlIEEgbnVtYmVyIG9yIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGZsb2F0LlxuICogQHJldHVybnMgVGhlIHZhbHVlIGFzIGEgbnVtYmVyLCBvciB1bmRlZmluZWQgaWYgaXQncyBudWxsL3VuZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmljdFBhcnNlRmxvYXQzMiA9ICh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGV4cGVjdEZsb2F0MzIocGFyc2VOdW1iZXIodmFsdWUpKTtcbiAgfVxuICByZXR1cm4gZXhwZWN0RmxvYXQzMih2YWx1ZSk7XG59O1xuXG4vLyBUaGlzIHJlZ2V4IG1hdGNoZXMgSlNPTi1zdHlsZSBudW1iZXJzLiBJbiBzaG9ydDpcbi8vICogVGhlIGludGVncmFsIG1heSBzdGFydCB3aXRoIGEgbmVnYXRpdmUgc2lnbiwgYnV0IG5vdCBhIHBvc2l0aXZlIG9uZVxuLy8gKiBObyBsZWFkaW5nIDAgb24gdGhlIGludGVncmFsIHVubGVzcyBpdCdzIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGEgJy4nXG4vLyAqIEV4cG9uZW50IGluZGljYXRlZCBieSBhIGNhc2UtaW5zZW5zaXRpdmUgJ0UnIG9wdGlvbmFsbHkgZm9sbG93ZWQgYnkgYVxuLy8gICBwb3NpdGl2ZS9uZWdhdGl2ZSBzaWduIGFuZCBzb21lIG51bWJlciBvZiBkaWdpdHMuXG4vLyBJdCBhbHNvIG1hdGNoZXMgYm90aCBwb3NpdGl2ZSBhbmQgbmVnYXRpdmUgaW5maW5pdHkgYXMgd2VsbCBhbmQgZXhwbGljaXQgTmFOLlxuY29uc3QgTlVNQkVSX1JFR0VYID0gLygtPyg/OjB8WzEtOV1cXGQqKSg/OlxcLlxcZCspPyg/OltlRV1bKy1dP1xcZCspPyl8KC0/SW5maW5pdHkpfChOYU4pL2c7XG5cbmNvbnN0IHBhcnNlTnVtYmVyID0gKHZhbHVlOiBzdHJpbmcpOiBudW1iZXIgPT4ge1xuICBjb25zdCBtYXRjaGVzID0gdmFsdWUubWF0Y2goTlVNQkVSX1JFR0VYKTtcbiAgaWYgKG1hdGNoZXMgPT09IG51bGwgfHwgbWF0Y2hlc1swXS5sZW5ndGggIT09IHZhbHVlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIHJlYWwgbnVtYmVyLCBnb3QgaW1wbGljaXQgTmFOYCk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xufTtcblxuLyoqXG4gKiBBc3NlcnRzIGEgdmFsdWUgaXMgYSBudW1iZXIgYW5kIHJldHVybnMgaXQuIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZ1xuICogcmVwcmVzZW50YXRpb24gb2YgYSBub24tbnVtZXJpYyBudW1iZXIgdHlwZSAoTmFOLCBJbmZpbml0eSwgLUluZmluaXR5KSxcbiAqIHRoZSB2YWx1ZSB3aWxsIGJlIHBhcnNlZC4gQW55IG90aGVyIHN0cmluZyB2YWx1ZSB3aWxsIHJlc3VsdCBpbiBhbiBleGNlcHRpb25cbiAqIGJlaW5nIHRocm93bi4gTnVsbCBvciB1bmRlZmluZWQgd2lsbCBiZSByZXR1cm5lZCBhcyB1bmRlZmluZWQuIEFueSBvdGhlclxuICogdHlwZSB3aWxsIHJlc3VsdCBpbiBhbiBleGNlcHRpb24gYmVpbmcgdGhyb3duLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBBIG51bWJlciBvciBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBub24tbnVtZXJpYyBmbG9hdC5cbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSBhcyBhIG51bWJlciwgb3IgdW5kZWZpbmVkIGlmIGl0J3MgbnVsbC91bmRlZmluZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBsaW1pdGVkUGFyc2VEb3VibGUgPSAodmFsdWU6IHN0cmluZyB8IG51bWJlcik6IG51bWJlciB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBwYXJzZUZsb2F0U3RyaW5nKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZXhwZWN0TnVtYmVyKHZhbHVlKTtcbn07XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGxpbWl0ZWRQYXJzZURvdWJsZVxuICovXG5leHBvcnQgY29uc3QgaGFuZGxlRmxvYXQgPSBsaW1pdGVkUGFyc2VEb3VibGU7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGxpbWl0ZWRQYXJzZURvdWJsZVxuICovXG5leHBvcnQgY29uc3QgbGltaXRlZFBhcnNlRmxvYXQgPSBsaW1pdGVkUGFyc2VEb3VibGU7XG5cbi8qKlxuICogQXNzZXJ0cyBhIHZhbHVlIGlzIGEgMzItYml0IGZsb2F0IGFuZCByZXR1cm5zIGl0LiBJZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmdcbiAqIHJlcHJlc2VudGF0aW9uIG9mIGEgbm9uLW51bWVyaWMgbnVtYmVyIHR5cGUgKE5hTiwgSW5maW5pdHksIC1JbmZpbml0eSksXG4gKiB0aGUgdmFsdWUgd2lsbCBiZSBwYXJzZWQuIEFueSBvdGhlciBzdHJpbmcgdmFsdWUgd2lsbCByZXN1bHQgaW4gYW4gZXhjZXB0aW9uXG4gKiBiZWluZyB0aHJvd24uIE51bGwgb3IgdW5kZWZpbmVkIHdpbGwgYmUgcmV0dXJuZWQgYXMgdW5kZWZpbmVkLiBBbnkgb3RoZXJcbiAqIHR5cGUgd2lsbCByZXN1bHQgaW4gYW4gZXhjZXB0aW9uIGJlaW5nIHRocm93bi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgQSBudW1iZXIgb3Igc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbm9uLW51bWVyaWMgZmxvYXQuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgYXMgYSBudW1iZXIsIG9yIHVuZGVmaW5lZCBpZiBpdCdzIG51bGwvdW5kZWZpbmVkLlxuICovXG5leHBvcnQgY29uc3QgbGltaXRlZFBhcnNlRmxvYXQzMiA9ICh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHBhcnNlRmxvYXRTdHJpbmcodmFsdWUpO1xuICB9XG4gIHJldHVybiBleHBlY3RGbG9hdDMyKHZhbHVlKTtcbn07XG5cbmNvbnN0IHBhcnNlRmxvYXRTdHJpbmcgPSAodmFsdWU6IHN0cmluZyk6IG51bWJlciA9PiB7XG4gIHN3aXRjaCAodmFsdWUpIHtcbiAgICBjYXNlIFwiTmFOXCI6XG4gICAgICByZXR1cm4gTmFOO1xuICAgIGNhc2UgXCJJbmZpbml0eVwiOlxuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIGNhc2UgXCItSW5maW5pdHlcIjpcbiAgICAgIHJldHVybiAtSW5maW5pdHk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHBhcnNlIGZsb2F0IHZhbHVlOiAke3ZhbHVlfWApO1xuICB9XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIHZhbHVlIGludG8gYW4gaW50ZWdlci4gSWYgdGhlIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkLCB1bmRlZmluZWRcbiAqIHdpbGwgYmUgcmV0dXJuZWQuIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSBwYXJzZWQgYnkgcGFyc2VGbG9hdFxuICogYW5kIHRoZSByZXN1bHQgd2lsbCBiZSBhc3NlcnRlZCB0byBiZSBhbiBpbnRlZ2VyLiBJZiB0aGUgcGFyc2VkIHZhbHVlIGlzIG5vdFxuICogYW4gaW50ZWdlciwgb3IgdGhlIHJhdyB2YWx1ZSBpcyBhbnkgdHlwZSBvdGhlciB0aGFuIGEgc3RyaW5nIG9yIG51bWJlciwgYW5cbiAqIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgQSBudW1iZXIgb3Igc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGludGVnZXIuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgYXMgYSBudW1iZXIsIG9yIHVuZGVmaW5lZCBpZiBpdCdzIG51bGwvdW5kZWZpbmVkLlxuICovXG5leHBvcnQgY29uc3Qgc3RyaWN0UGFyc2VMb25nID0gKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIpOiBudW1iZXIgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgLy8gcGFyc2VJbnQgY2FuJ3QgYmUgdXNlZCBoZXJlLCBiZWNhdXNlIGl0IHdpbGwgc2lsZW50bHkgZGlzY2FyZCBhbnlcbiAgICAvLyBleGlzdGluZyBkZWNpbWFscy4gV2Ugd2FudCB0byBpbnN0ZWFkIHRocm93IGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkuXG4gICAgcmV0dXJuIGV4cGVjdExvbmcocGFyc2VOdW1iZXIodmFsdWUpKTtcbiAgfVxuICByZXR1cm4gZXhwZWN0TG9uZyh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBzdHJpY3RQYXJzZUxvbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmljdFBhcnNlSW50ID0gc3RyaWN0UGFyc2VMb25nO1xuXG4vKipcbiAqIFBhcnNlcyBhIHZhbHVlIGludG8gYSAzMi1iaXQgaW50ZWdlci4gSWYgdGhlIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkLCB1bmRlZmluZWRcbiAqIHdpbGwgYmUgcmV0dXJuZWQuIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSBwYXJzZWQgYnkgcGFyc2VGbG9hdFxuICogYW5kIHRoZSByZXN1bHQgd2lsbCBiZSBhc3NlcnRlZCB0byBiZSBhbiBpbnRlZ2VyLiBJZiB0aGUgcGFyc2VkIHZhbHVlIGlzIG5vdFxuICogYW4gaW50ZWdlciwgb3IgdGhlIHJhdyB2YWx1ZSBpcyBhbnkgdHlwZSBvdGhlciB0aGFuIGEgc3RyaW5nIG9yIG51bWJlciwgYW5cbiAqIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgQSBudW1iZXIgb3Igc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgMzItYml0IGludGVnZXIuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgYXMgYSBudW1iZXIsIG9yIHVuZGVmaW5lZCBpZiBpdCdzIG51bGwvdW5kZWZpbmVkLlxuICovXG5leHBvcnQgY29uc3Qgc3RyaWN0UGFyc2VJbnQzMiA9ICh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIC8vIHBhcnNlSW50IGNhbid0IGJlIHVzZWQgaGVyZSwgYmVjYXVzZSBpdCB3aWxsIHNpbGVudGx5IGRpc2NhcmQgYW55XG4gICAgLy8gZXhpc3RpbmcgZGVjaW1hbHMuIFdlIHdhbnQgdG8gaW5zdGVhZCB0aHJvdyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgYW55LlxuICAgIHJldHVybiBleHBlY3RJbnQzMihwYXJzZU51bWJlcih2YWx1ZSkpO1xuICB9XG4gIHJldHVybiBleHBlY3RJbnQzMih2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIHZhbHVlIGludG8gYSAxNi1iaXQgaW50ZWdlci4gSWYgdGhlIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkLCB1bmRlZmluZWRcbiAqIHdpbGwgYmUgcmV0dXJuZWQuIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSBwYXJzZWQgYnkgcGFyc2VGbG9hdFxuICogYW5kIHRoZSByZXN1bHQgd2lsbCBiZSBhc3NlcnRlZCB0byBiZSBhbiBpbnRlZ2VyLiBJZiB0aGUgcGFyc2VkIHZhbHVlIGlzIG5vdFxuICogYW4gaW50ZWdlciwgb3IgdGhlIHJhdyB2YWx1ZSBpcyBhbnkgdHlwZSBvdGhlciB0aGFuIGEgc3RyaW5nIG9yIG51bWJlciwgYW5cbiAqIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgQSBudW1iZXIgb3Igc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgMTYtYml0IGludGVnZXIuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgYXMgYSBudW1iZXIsIG9yIHVuZGVmaW5lZCBpZiBpdCdzIG51bGwvdW5kZWZpbmVkLlxuICovXG5leHBvcnQgY29uc3Qgc3RyaWN0UGFyc2VTaG9ydCA9ICh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIC8vIHBhcnNlSW50IGNhbid0IGJlIHVzZWQgaGVyZSwgYmVjYXVzZSBpdCB3aWxsIHNpbGVudGx5IGRpc2NhcmQgYW55XG4gICAgLy8gZXhpc3RpbmcgZGVjaW1hbHMuIFdlIHdhbnQgdG8gaW5zdGVhZCB0aHJvdyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgYW55LlxuICAgIHJldHVybiBleHBlY3RTaG9ydChwYXJzZU51bWJlcih2YWx1ZSkpO1xuICB9XG4gIHJldHVybiBleHBlY3RTaG9ydCh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIHZhbHVlIGludG8gYW4gOC1iaXQgaW50ZWdlci4gSWYgdGhlIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkLCB1bmRlZmluZWRcbiAqIHdpbGwgYmUgcmV0dXJuZWQuIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSBwYXJzZWQgYnkgcGFyc2VGbG9hdFxuICogYW5kIHRoZSByZXN1bHQgd2lsbCBiZSBhc3NlcnRlZCB0byBiZSBhbiBpbnRlZ2VyLiBJZiB0aGUgcGFyc2VkIHZhbHVlIGlzIG5vdFxuICogYW4gaW50ZWdlciwgb3IgdGhlIHJhdyB2YWx1ZSBpcyBhbnkgdHlwZSBvdGhlciB0aGFuIGEgc3RyaW5nIG9yIG51bWJlciwgYW5cbiAqIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgQSBudW1iZXIgb3Igc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIDgtYml0IGludGVnZXIuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgYXMgYSBudW1iZXIsIG9yIHVuZGVmaW5lZCBpZiBpdCdzIG51bGwvdW5kZWZpbmVkLlxuICovXG5leHBvcnQgY29uc3Qgc3RyaWN0UGFyc2VCeXRlID0gKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIpOiBudW1iZXIgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgLy8gcGFyc2VJbnQgY2FuJ3QgYmUgdXNlZCBoZXJlLCBiZWNhdXNlIGl0IHdpbGwgc2lsZW50bHkgZGlzY2FyZCBhbnlcbiAgICAvLyBleGlzdGluZyBkZWNpbWFscy4gV2Ugd2FudCB0byBpbnN0ZWFkIHRocm93IGFuIGVycm9yIGlmIHRoZXJlIGFyZSBhbnkuXG4gICAgcmV0dXJuIGV4cGVjdEJ5dGUocGFyc2VOdW1iZXIodmFsdWUpKTtcbiAgfVxuICByZXR1cm4gZXhwZWN0Qnl0ZSh2YWx1ZSk7XG59O1xuIl19