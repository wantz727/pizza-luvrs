"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.strictParseByte = exports.strictParseShort = exports.strictParseInt32 = exports.strictParseInt = exports.strictParseLong = exports.limitedParseFloat32 = exports.limitedParseFloat = exports.handleFloat = exports.limitedParseDouble = exports.strictParseFloat32 = exports.strictParseFloat = exports.strictParseDouble = exports.expectString = exports.expectObject = exports.expectNonNull = exports.expectByte = exports.expectShort = exports.expectInt32 = exports.expectInt = exports.expectLong = exports.expectFloat32 = exports.expectNumber = exports.expectBoolean = exports.parseBoolean = void 0;
/**
 * Give an input string, strictly parses a boolean value.
 *
 * @param value The boolean string to parse.
 * @returns true for "true", false for "false", otherwise an error is thrown.
 */
const parseBoolean = (value) => {
    switch (value) {
        case "true":
            return true;
        case "false":
            return false;
        default:
            throw new Error(`Unable to parse boolean value "${value}"`);
    }
};
exports.parseBoolean = parseBoolean;
/*
 * Asserts a value is a boolean and returns it.
 *
 * @param value A value that is expected to be a boolean.
 * @returns The value if it's a boolean, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
const expectBoolean = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "boolean") {
        return value;
    }
    throw new TypeError(`Expected boolean, got ${typeof value}`);
};
exports.expectBoolean = expectBoolean;
/**
 * Asserts a value is a number and returns it.
 *
 * @param value A value that is expected to be a number.
 * @returns The value if it's a number, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
const expectNumber = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "number") {
        return value;
    }
    throw new TypeError(`Expected number, got ${typeof value}`);
};
exports.expectNumber = expectNumber;
const MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
/**
 * Asserts a value is a 32-bit float and returns it.
 *
 * @param value A value that is expected to be a 32-bit float.
 * @returns The value if it's a float, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
const expectFloat32 = (value) => {
    const expected = (0, exports.expectNumber)(value);
    if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
        // IEEE-754 is an imperfect representation for floats. Consider the simple
        // value `0.1`. The representation in a 32-bit float would look like:
        //
        // 0 01111011 10011001100110011001101
        // Actual value: 0.100000001490116119384765625
        //
        // Note the repeating pattern of `1001` in the fraction part. The 64-bit
        // representation is similar:
        //
        // 0 01111111011 1001100110011001100110011001100110011001100110011010
        // Actual value: 0.100000000000000005551115123126
        //
        // So even for what we consider simple numbers, the representation differs
        // between the two formats. And it's non-obvious how one might look at the
        // 64-bit value (which is how JS represents numbers) and determine if it
        // can be represented reasonably in the 32-bit form. Primarily because you
        // can't know whether the intent was to represent `0.1` or the actual
        // value in memory. But even if you have both the decimal value and the
        // double value, that still doesn't communicate the intended precision.
        //
        // So rather than attempting to divine the intent of the caller, we instead
        // do some simple bounds checking to make sure the value is passingly
        // representable in a 32-bit float. It's not perfect, but it's good enough.
        // Perfect, even if possible to achieve, would likely be too costly to
        // be worth it.
        //
        // The maximum value of a 32-bit float. Since the 64-bit representation
        // could be more or less, we just round it up to the nearest whole number.
        // This further reduces our ability to be certain of the value, but it's
        // an acceptable tradeoff.
        //
        // Compare against the absolute value to simplify things.
        if (Math.abs(expected) > MAX_FLOAT) {
            throw new TypeError(`Expected 32-bit float, got ${value}`);
        }
    }
    return expected;
};
exports.expectFloat32 = expectFloat32;
/**
 * Asserts a value is an integer and returns it.
 *
 * @param value A value that is expected to be an integer.
 * @returns The value if it's an integer, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
const expectLong = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (Number.isInteger(value) && !Number.isNaN(value)) {
        return value;
    }
    throw new TypeError(`Expected integer, got ${typeof value}`);
};
exports.expectLong = expectLong;
/**
 * @deprecated Use expectLong
 */
exports.expectInt = exports.expectLong;
/**
 * Asserts a value is a 32-bit integer and returns it.
 *
 * @param value A value that is expected to be an integer.
 * @returns The value if it's an integer, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
const expectInt32 = (value) => expectSizedInt(value, 32);
exports.expectInt32 = expectInt32;
/**
 * Asserts a value is a 16-bit integer and returns it.
 *
 * @param value A value that is expected to be an integer.
 * @returns The value if it's an integer, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
const expectShort = (value) => expectSizedInt(value, 16);
exports.expectShort = expectShort;
/**
 * Asserts a value is an 8-bit integer and returns it.
 *
 * @param value A value that is expected to be an integer.
 * @returns The value if it's an integer, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
const expectByte = (value) => expectSizedInt(value, 8);
exports.expectByte = expectByte;
const expectSizedInt = (value, size) => {
    const expected = (0, exports.expectLong)(value);
    if (expected !== undefined && castInt(expected, size) !== expected) {
        throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
    }
    return expected;
};
const castInt = (value, size) => {
    switch (size) {
        case 32:
            return Int32Array.of(value)[0];
        case 16:
            return Int16Array.of(value)[0];
        case 8:
            return Int8Array.of(value)[0];
    }
};
/**
 * Asserts a value is not null or undefined and returns it, or throws an error.
 *
 * @param value A value that is expected to be defined
 * @param location The location where we're expecting to find a defined object (optional)
 * @returns The value if it's not undefined, otherwise throws an error
 */
const expectNonNull = (value, location) => {
    if (value === null || value === undefined) {
        if (location) {
            throw new TypeError(`Expected a non-null value for ${location}`);
        }
        throw new TypeError("Expected a non-null value");
    }
    return value;
};
exports.expectNonNull = expectNonNull;
/**
 * Asserts a value is an JSON-like object and returns it. This is expected to be used
 * with values parsed from JSON (arrays, objects, numbers, strings, booleans).
 *
 * @param value A value that is expected to be an object
 * @returns The value if it's an object, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
const expectObject = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "object" && !Array.isArray(value)) {
        return value;
    }
    throw new TypeError(`Expected object, got ${typeof value}`);
};
exports.expectObject = expectObject;
/**
 * Asserts a value is a string and returns it.
 *
 * @param value A value that is expected to be a string.
 * @returns The value if it's a string, undefined if it's null/undefined,
 *   otherwise an error is thrown.
 */
const expectString = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        return value;
    }
    throw new TypeError(`Expected string, got ${typeof value}`);
};
exports.expectString = expectString;
/**
 * Parses a value into a double. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by the standard
 * parseFloat with one exception: NaN may only be explicitly set as the string
 * "NaN", any implicit Nan values will result in an error being thrown. If any
 * other type is provided, an exception will be thrown.
 *
 * @param value A number or string representation of a double.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
const strictParseDouble = (value) => {
    if (typeof value == "string") {
        return (0, exports.expectNumber)(parseNumber(value));
    }
    return (0, exports.expectNumber)(value);
};
exports.strictParseDouble = strictParseDouble;
/**
 * @deprecated Use strictParseDouble
 */
exports.strictParseFloat = exports.strictParseDouble;
/**
 * Parses a value into a float. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by the standard
 * parseFloat with one exception: NaN may only be explicitly set as the string
 * "NaN", any implicit Nan values will result in an error being thrown. If any
 * other type is provided, an exception will be thrown.
 *
 * @param value A number or string representation of a float.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
const strictParseFloat32 = (value) => {
    if (typeof value == "string") {
        return (0, exports.expectFloat32)(parseNumber(value));
    }
    return (0, exports.expectFloat32)(value);
};
exports.strictParseFloat32 = strictParseFloat32;
// This regex matches JSON-style numbers. In short:
// * The integral may start with a negative sign, but not a positive one
// * No leading 0 on the integral unless it's immediately followed by a '.'
// * Exponent indicated by a case-insensitive 'E' optionally followed by a
//   positive/negative sign and some number of digits.
// It also matches both positive and negative infinity as well and explicit NaN.
const NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
const parseNumber = (value) => {
    const matches = value.match(NUMBER_REGEX);
    if (matches === null || matches[0].length !== value.length) {
        throw new TypeError(`Expected real number, got implicit NaN`);
    }
    return parseFloat(value);
};
/**
 * Asserts a value is a number and returns it. If the value is a string
 * representation of a non-numeric number type (NaN, Infinity, -Infinity),
 * the value will be parsed. Any other string value will result in an exception
 * being thrown. Null or undefined will be returned as undefined. Any other
 * type will result in an exception being thrown.
 *
 * @param value A number or string representation of a non-numeric float.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
const limitedParseDouble = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return (0, exports.expectNumber)(value);
};
exports.limitedParseDouble = limitedParseDouble;
/**
 * @deprecated Use limitedParseDouble
 */
exports.handleFloat = exports.limitedParseDouble;
/**
 * @deprecated Use limitedParseDouble
 */
exports.limitedParseFloat = exports.limitedParseDouble;
/**
 * Asserts a value is a 32-bit float and returns it. If the value is a string
 * representation of a non-numeric number type (NaN, Infinity, -Infinity),
 * the value will be parsed. Any other string value will result in an exception
 * being thrown. Null or undefined will be returned as undefined. Any other
 * type will result in an exception being thrown.
 *
 * @param value A number or string representation of a non-numeric float.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
const limitedParseFloat32 = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return (0, exports.expectFloat32)(value);
};
exports.limitedParseFloat32 = limitedParseFloat32;
const parseFloatString = (value) => {
    switch (value) {
        case "NaN":
            return NaN;
        case "Infinity":
            return Infinity;
        case "-Infinity":
            return -Infinity;
        default:
            throw new Error(`Unable to parse float value: ${value}`);
    }
};
/**
 * Parses a value into an integer. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by parseFloat
 * and the result will be asserted to be an integer. If the parsed value is not
 * an integer, or the raw value is any type other than a string or number, an
 * exception will be thrown.
 *
 * @param value A number or string representation of an integer.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
const strictParseLong = (value) => {
    if (typeof value === "string") {
        // parseInt can't be used here, because it will silently discard any
        // existing decimals. We want to instead throw an error if there are any.
        return (0, exports.expectLong)(parseNumber(value));
    }
    return (0, exports.expectLong)(value);
};
exports.strictParseLong = strictParseLong;
/**
 * @deprecated Use strictParseLong
 */
exports.strictParseInt = exports.strictParseLong;
/**
 * Parses a value into a 32-bit integer. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by parseFloat
 * and the result will be asserted to be an integer. If the parsed value is not
 * an integer, or the raw value is any type other than a string or number, an
 * exception will be thrown.
 *
 * @param value A number or string representation of a 32-bit integer.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
const strictParseInt32 = (value) => {
    if (typeof value === "string") {
        // parseInt can't be used here, because it will silently discard any
        // existing decimals. We want to instead throw an error if there are any.
        return (0, exports.expectInt32)(parseNumber(value));
    }
    return (0, exports.expectInt32)(value);
};
exports.strictParseInt32 = strictParseInt32;
/**
 * Parses a value into a 16-bit integer. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by parseFloat
 * and the result will be asserted to be an integer. If the parsed value is not
 * an integer, or the raw value is any type other than a string or number, an
 * exception will be thrown.
 *
 * @param value A number or string representation of a 16-bit integer.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
const strictParseShort = (value) => {
    if (typeof value === "string") {
        // parseInt can't be used here, because it will silently discard any
        // existing decimals. We want to instead throw an error if there are any.
        return (0, exports.expectShort)(parseNumber(value));
    }
    return (0, exports.expectShort)(value);
};
exports.strictParseShort = strictParseShort;
/**
 * Parses a value into an 8-bit integer. If the value is null or undefined, undefined
 * will be returned. If the value is a string, it will be parsed by parseFloat
 * and the result will be asserted to be an integer. If the parsed value is not
 * an integer, or the raw value is any type other than a string or number, an
 * exception will be thrown.
 *
 * @param value A number or string representation of an 8-bit integer.
 * @returns The value as a number, or undefined if it's null/undefined.
 */
const strictParseByte = (value) => {
    if (typeof value === "string") {
        // parseInt can't be used here, because it will silently discard any
        // existing decimals. We want to instead throw an error if there are any.
        return (0, exports.expectByte)(parseNumber(value));
    }
    return (0, exports.expectByte)(value);
};
exports.strictParseByte = strictParseByte;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2UtdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcGFyc2UtdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7Ozs7O0dBS0c7QUFDSSxNQUFNLFlBQVksR0FBRyxDQUFDLEtBQWEsRUFBVyxFQUFFO0lBQ3JELFFBQVEsS0FBSyxFQUFFO1FBQ2IsS0FBSyxNQUFNO1lBQ1QsT0FBTyxJQUFJLENBQUM7UUFDZCxLQUFLLE9BQU87WUFDVixPQUFPLEtBQUssQ0FBQztRQUNmO1lBQ0UsTUFBTSxJQUFJLEtBQUssQ0FBQyxrQ0FBa0MsS0FBSyxHQUFHLENBQUMsQ0FBQztLQUMvRDtBQUNILENBQUMsQ0FBQztBQVRXLFFBQUEsWUFBWSxnQkFTdkI7QUFFRjs7Ozs7O0dBTUc7QUFDSSxNQUFNLGFBQWEsR0FBRyxDQUFDLEtBQVUsRUFBdUIsRUFBRTtJQUMvRCxJQUFJLEtBQUssS0FBSyxJQUFJLElBQUksS0FBSyxLQUFLLFNBQVMsRUFBRTtRQUN6QyxPQUFPLFNBQVMsQ0FBQztLQUNsQjtJQUNELElBQUksT0FBTyxLQUFLLEtBQUssU0FBUyxFQUFFO1FBQzlCLE9BQU8sS0FBSyxDQUFDO0tBQ2Q7SUFDRCxNQUFNLElBQUksU0FBUyxDQUFDLHlCQUF5QixPQUFPLEtBQUssRUFBRSxDQUFDLENBQUM7QUFDL0QsQ0FBQyxDQUFDO0FBUlcsUUFBQSxhQUFhLGlCQVF4QjtBQUVGOzs7Ozs7R0FNRztBQUNJLE1BQU0sWUFBWSxHQUFHLENBQUMsS0FBVSxFQUFzQixFQUFFO0lBQzdELElBQUksS0FBSyxLQUFLLElBQUksSUFBSSxLQUFLLEtBQUssU0FBUyxFQUFFO1FBQ3pDLE9BQU8sU0FBUyxDQUFDO0tBQ2xCO0lBQ0QsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7UUFDN0IsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUNELE1BQU0sSUFBSSxTQUFTLENBQUMsd0JBQXdCLE9BQU8sS0FBSyxFQUFFLENBQUMs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Q0FBQyxDQUFDLENBQUM7S0FDeEM7SUFDRCxPQUFPLElBQUEsbUJBQVcsRUFBQyxLQUFLLENBQUMsQ0FBQztBQUM1QixDQUFDLENBQUM7QUFQVyxRQUFBLGdCQUFnQixvQkFPM0I7QUFFRjs7Ozs7Ozs7O0dBU0c7QUFDSSxNQUFNLGdCQUFnQixHQUFHLENBQUMsS0FBc0IsRUFBc0IsRUFBRTtJQUM3RSxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBRTtRQUM3QixvRUFBb0U7UUFDcEUseUVBQXlFO1FBQ3pFLE9BQU8sSUFBQSxtQkFBVyxFQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0tBQ3hDO0lBQ0QsT0FBTyxJQUFBLG1CQUFXLEVBQUMsS0FBSyxDQUFDLENBQUM7QUFDNUIsQ0FBQyxDQUFDO0FBUFcsUUFBQSxnQkFBZ0Isb0JBTzNCO0FBRUY7Ozs7Ozs7OztHQVNHO0FBQ0ksTUFBTSxlQUFlLEdBQUcsQ0FBQyxLQUFzQixFQUFzQixFQUFFO0lBQzVFLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxFQUFFO1FBQzdCLG9FQUFvRTtRQUNwRSx5RUFBeUU7UUFDekUsT0FBTyxJQUFBLGtCQUFVLEVBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7S0FDdkM7SUFDRCxPQUFPLElBQUEsa0JBQVUsRUFBQyxLQUFLLENBQUMsQ0FBQztBQUMzQixDQUFDLENBQUM7QUFQVyxRQUFBLGVBQWUsbUJBTzFCIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBHaXZlIGFuIGlucHV0IHN0cmluZywgc3RyaWN0bHkgcGFyc2VzIGEgYm9vbGVhbiB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgVGhlIGJvb2xlYW4gc3RyaW5nIHRvIHBhcnNlLlxuICogQHJldHVybnMgdHJ1ZSBmb3IgXCJ0cnVlXCIsIGZhbHNlIGZvciBcImZhbHNlXCIsIG90aGVyd2lzZSBhbiBlcnJvciBpcyB0aHJvd24uXG4gKi9cbmV4cG9ydCBjb25zdCBwYXJzZUJvb2xlYW4gPSAodmFsdWU6IHN0cmluZyk6IGJvb2xlYW4gPT4ge1xuICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgY2FzZSBcInRydWVcIjpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgXCJmYWxzZVwiOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBwYXJzZSBib29sZWFuIHZhbHVlIFwiJHt2YWx1ZX1cImApO1xuICB9XG59O1xuXG4vKlxuICogQXNzZXJ0cyBhIHZhbHVlIGlzIGEgYm9vbGVhbiBhbmQgcmV0dXJucyBpdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgQSB2YWx1ZSB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGEgYm9vbGVhbi5cbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSBpZiBpdCdzIGEgYm9vbGVhbiwgdW5kZWZpbmVkIGlmIGl0J3MgbnVsbC91bmRlZmluZWQsXG4gKiAgIG90aGVyd2lzZSBhbiBlcnJvciBpcyB0aHJvd24uXG4gKi9cbmV4cG9ydCBjb25zdCBleHBlY3RCb29sZWFuID0gKHZhbHVlOiBhbnkpOiBib29sZWFuIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGJvb2xlYW4sIGdvdCAke3R5cGVvZiB2YWx1ZX1gKTtcbn07XG5cbi8qKlxuICogQXNzZXJ0cyBhIHZhbHVlIGlzIGEgbnVtYmVyIGFuZCByZXR1cm5zIGl0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBBIHZhbHVlIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgYSBudW1iZXIuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgaWYgaXQncyBhIG51bWJlciwgdW5kZWZpbmVkIGlmIGl0J3MgbnVsbC91bmRlZmluZWQsXG4gKiAgIG90aGVyd2lzZSBhbiBlcnJvciBpcyB0aHJvd24uXG4gKi9cbmV4cG9ydCBjb25zdCBleHBlY3ROdW1iZXIgPSAodmFsdWU6IGFueSk6IG51bWJlciB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIG51bWJlciwgZ290ICR7dHlwZW9mIHZhbHVlfWApO1xufTtcblxuY29uc3QgTUFYX0ZMT0FUID0gTWF0aC5jZWlsKDIgKiogMTI3ICogKDIgLSAyICoqIC0yMykpO1xuXG4vKipcbiAqIEFzc2VydHMgYSB2YWx1ZSBpcyBhIDMyLWJpdCBmbG9hdCBhbmQgcmV0dXJucyBpdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgQSB2YWx1ZSB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGEgMzItYml0IGZsb2F0LlxuICogQHJldHVybnMgVGhlIHZhbHVlIGlmIGl0J3MgYSBmbG9hdCwgdW5kZWZpbmVkIGlmIGl0J3MgbnVsbC91bmRlZmluZWQsXG4gKiAgIG90aGVyd2lzZSBhbiBlcnJvciBpcyB0aHJvd24uXG4gKi9cbmV4cG9ydCBjb25zdCBleHBlY3RGbG9hdDMyID0gKHZhbHVlOiBhbnkpOiBudW1iZXIgfCB1bmRlZmluZWQgPT4ge1xuICBjb25zdCBleHBlY3RlZCA9IGV4cGVjdE51bWJlcih2YWx1ZSk7XG4gIGlmIChleHBlY3RlZCAhPT0gdW5kZWZpbmVkICYmICFOdW1iZXIuaXNOYU4oZXhwZWN0ZWQpICYmIGV4cGVjdGVkICE9PSBJbmZpbml0eSAmJiBleHBlY3RlZCAhPT0gLUluZmluaXR5KSB7XG4gICAgLy8gSUVFRS03NTQgaXMgYW4gaW1wZXJmZWN0IHJlcHJlc2VudGF0aW9uIGZvciBmbG9hdHMuIENvbnNpZGVyIHRoZSBzaW1wbGVcbiAgICAvLyB2YWx1ZSBgMC4xYC4gVGhlIHJlcHJlc2VudGF0aW9uIGluIGEgMzItYml0IGZsb2F0IHdvdWxkIGxvb2sgbGlrZTpcbiAgICAvL1xuICAgIC8vIDAgMDExMTEwMTEgMTAwMTEwMDExMDAxMTAwMTEwMDExMDFcbiAgICAvLyBBY3R1YWwgdmFsdWU6IDAuMTAwMDAwMDAxNDkwMTE2MTE5Mzg0NzY1NjI1XG4gICAgLy9cbiAgICAvLyBOb3RlIHRoZSByZXBlYXRpbmcgcGF0dGVybiBvZiBgMTAwMWAgaW4gdGhlIGZyYWN0aW9uIHBhcnQuIFRoZSA2NC1iaXRcbiAgICAvLyByZXByZXNlbnRhdGlvbiBpcyBzaW1pbGFyOlxuICAgIC8vXG4gICAgLy8gMCAwMTExMTExMTAxMSAxMDAxMTAwMTEwMDExMDAxMTAwMTEwMDExMDAxMTAwMTEwMDExMDAxMTAwMTEwMDExMDEwXG4gICAgLy8gQWN0dWFsIHZhbHVlOiAwLjEwMDAwMDAwMDAwMDAwMDAwNTU1MTExNTEyMzEyNlxuICAgIC8vXG4gICAgLy8gU28gZXZlbiBmb3Igd2hhdCB3ZSBjb25zaWRlciBzaW1wbGUgbnVtYmVycywgdGhlIHJlcHJlc2VudGF0aW9uIGRpZmZlcnNcbiAgICAvLyBiZXR3ZWVuIHRoZSB0d28gZm9ybWF0cy4gQW5kIGl0J3Mgbm9uLW9idmlvdXMgaG93IG9uZSBtaWdodCBsb29rIGF0IHRoZVxuICAgIC8vIDY0LWJpdCB2YWx1ZSAod2hpY2ggaXMgaG93IEpTIHJlcHJlc2VudHMgbnVtYmVycykgYW5kIGRldGVybWluZSBpZiBpdFxuICAgIC8vIGNhbiBiZSByZXByZXNlbnRlZCByZWFzb25hYmx5IGluIHRoZSAzMi1iaXQgZm9ybS4gUHJpbWFyaWx5IGJlY2F1c2UgeW91XG4gICAgLy8gY2FuJ3Qga25vdyB3aGV0aGVyIHRoZSBpbnRlbnQgd2FzIHRvIHJlcHJlc2VudCBgMC4xYCBvciB0aGUgYWN0dWFsXG4gICAgLy8gdmFsdWUgaW4gbWVtb3J5LiBCdXQgZXZlbiBpZiB5b3UgaGF2ZSBib3RoIHRoZSBkZWNpbWFsIHZhbHVlIGFuZCB0aGVcbiAgICAvLyBkb3VibGUgdmFsdWUsIHRoYXQgc3RpbGwgZG9lc24ndCBjb21tdW5pY2F0ZSB0aGUgaW50ZW5kZWQgcHJlY2lzaW9uLlxuICAgIC8vXG4gICAgLy8gU28gcmF0aGVyIHRoYW4gYXR0ZW1wdGluZyB0byBkaXZpbmUgdGhlIGludGVudCBvZiB0aGUgY2FsbGVyLCB3ZSBpbnN0ZWFkXG4gICAgLy8gZG8gc29tZSBzaW1wbGUgYm91bmRzIGNoZWNraW5nIHRvIG1ha2Ugc3VyZSB0aGUgdmFsdWUgaXMgcGFzc2luZ2x5XG4gICAgLy8gcmVwcmVzZW50YWJsZSBpbiBhIDMyLWJpdCBmbG9hdC4gSXQncyBub3QgcGVyZmVjdCwgYnV0IGl0J3MgZ29vZCBlbm91Z2guXG4gICAgLy8gUGVyZmVjdCwgZXZlbiBpZiBwb3NzaWJsZSB0byBhY2hpZXZlLCB3b3VsZCBsaWtlbHkgYmUgdG9vIGNvc3RseSB0b1xuICAgIC8vIGJlIHdvcnRoIGl0LlxuICAgIC8vXG4gICAgLy8gVGhlIG1heGltdW0gdmFsdWUgb2YgYSAzMi1iaXQgZmxvYXQuIFNpbmNlIHRoZSA2NC1iaXQgcmVwcmVzZW50YXRpb25cbiAgICAvLyBjb3VsZCBiZSBtb3JlIG9yIGxlc3MsIHdlIGp1c3Qgcm91bmQgaXQgdXAgdG8gdGhlIG5lYXJlc3Qgd2hvbGUgbnVtYmVyLlxuICAgIC8vIFRoaXMgZnVydGhlciByZWR1Y2VzIG91ciBhYmlsaXR5IHRvIGJlIGNlcnRhaW4gb2YgdGhlIHZhbHVlLCBidXQgaXQnc1xuICAgIC8vIGFuIGFjY2VwdGFibGUgdHJhZGVvZmYuXG4gICAgLy9cbiAgICAvLyBDb21wYXJlIGFnYWluc3QgdGhlIGFic29sdXRlIHZhbHVlIHRvIHNpbXBsaWZ5IHRoaW5ncy5cbiAgICBpZiAoTWF0aC5hYnMoZXhwZWN0ZWQpID4gTUFYX0ZMT0FUKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCAzMi1iaXQgZmxvYXQsIGdvdCAke3ZhbHVlfWApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXhwZWN0ZWQ7XG59O1xuXG4vKipcbiAqIEFzc2VydHMgYSB2YWx1ZSBpcyBhbiBpbnRlZ2VyIGFuZCByZXR1cm5zIGl0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBBIHZhbHVlIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gaW50ZWdlci5cbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSBpZiBpdCdzIGFuIGludGVnZXIsIHVuZGVmaW5lZCBpZiBpdCdzIG51bGwvdW5kZWZpbmVkLFxuICogICBvdGhlcndpc2UgYW4gZXJyb3IgaXMgdGhyb3duLlxuICovXG5leHBvcnQgY29uc3QgZXhwZWN0TG9uZyA9ICh2YWx1ZTogYW55KTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSAmJiAhTnVtYmVyLmlzTmFOKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBpbnRlZ2VyLCBnb3QgJHt0eXBlb2YgdmFsdWV9YCk7XG59O1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBleHBlY3RMb25nXG4gKi9cbmV4cG9ydCBjb25zdCBleHBlY3RJbnQgPSBleHBlY3RMb25nO1xuXG4vKipcbiAqIEFzc2VydHMgYSB2YWx1ZSBpcyBhIDMyLWJpdCBpbnRlZ2VyIGFuZCByZXR1cm5zIGl0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBBIHZhbHVlIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gaW50ZWdlci5cbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSBpZiBpdCdzIGFuIGludGVnZXIsIHVuZGVmaW5lZCBpZiBpdCdzIG51bGwvdW5kZWZpbmVkLFxuICogICBvdGhlcndpc2UgYW4gZXJyb3IgaXMgdGhyb3duLlxuICovXG5leHBvcnQgY29uc3QgZXhwZWN0SW50MzIgPSAodmFsdWU6IGFueSk6IG51bWJlciB8IHVuZGVmaW5lZCA9PiBleHBlY3RTaXplZEludCh2YWx1ZSwgMzIpO1xuXG4vKipcbiAqIEFzc2VydHMgYSB2YWx1ZSBpcyBhIDE2LWJpdCBpbnRlZ2VyIGFuZCByZXR1cm5zIGl0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBBIHZhbHVlIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gaW50ZWdlci5cbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSBpZiBpdCdzIGFuIGludGVnZXIsIHVuZGVmaW5lZCBpZiBpdCdzIG51bGwvdW5kZWZpbmVkLFxuICogICBvdGhlcndpc2UgYW4gZXJyb3IgaXMgdGhyb3duLlxuICovXG5leHBvcnQgY29uc3QgZXhwZWN0U2hvcnQgPSAodmFsdWU6IGFueSk6IG51bWJlciB8IHVuZGVmaW5lZCA9PiBleHBlY3RTaXplZEludCh2YWx1ZSwgMTYpO1xuXG4vKipcbiAqIEFzc2VydHMgYSB2YWx1ZSBpcyBhbiA4LWJpdCBpbnRlZ2VyIGFuZCByZXR1cm5zIGl0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBBIHZhbHVlIHRoYXQgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gaW50ZWdlci5cbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSBpZiBpdCdzIGFuIGludGVnZXIsIHVuZGVmaW5lZCBpZiBpdCdzIG51bGwvdW5kZWZpbmVkLFxuICogICBvdGhlcndpc2UgYW4gZXJyb3IgaXMgdGhyb3duLlxuICovXG5leHBvcnQgY29uc3QgZXhwZWN0Qnl0ZSA9ICh2YWx1ZTogYW55KTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IGV4cGVjdFNpemVkSW50KHZhbHVlLCA4KTtcblxudHlwZSBJbnRTaXplID0gMzIgfCAxNiB8IDg7XG5cbmNvbnN0IGV4cGVjdFNpemVkSW50ID0gKHZhbHVlOiBhbnksIHNpemU6IEludFNpemUpOiBudW1iZXIgfCB1bmRlZmluZWQgPT4ge1xuICBjb25zdCBleHBlY3RlZCA9IGV4cGVjdExvbmcodmFsdWUpO1xuICBpZiAoZXhwZWN0ZWQgIT09IHVuZGVmaW5lZCAmJiBjYXN0SW50KGV4cGVjdGVkLCBzaXplKSAhPT0gZXhwZWN0ZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCAke3NpemV9LWJpdCBpbnRlZ2VyLCBnb3QgJHt2YWx1ZX1gKTtcbiAgfVxuICByZXR1cm4gZXhwZWN0ZWQ7XG59O1xuXG5jb25zdCBjYXN0SW50ID0gKHZhbHVlOiBudW1iZXIsIHNpemU6IEludFNpemUpID0+IHtcbiAgc3dpdGNoIChzaXplKSB7XG4gICAgY2FzZSAzMjpcbiAgICAgIHJldHVybiBJbnQzMkFycmF5Lm9mKHZhbHVlKVswXTtcbiAgICBjYXNlIDE2OlxuICAgICAgcmV0dXJuIEludDE2QXJyYXkub2YodmFsdWUpWzBdO1xuICAgIGNhc2UgODpcbiAgICAgIHJldHVybiBJbnQ4QXJyYXkub2YodmFsdWUpWzBdO1xuICB9XG59O1xuXG4vKipcbiAqIEFzc2VydHMgYSB2YWx1ZSBpcyBub3QgbnVsbCBvciB1bmRlZmluZWQgYW5kIHJldHVybnMgaXQsIG9yIHRocm93cyBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgQSB2YWx1ZSB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGRlZmluZWRcbiAqIEBwYXJhbSBsb2NhdGlvbiBUaGUgbG9jYXRpb24gd2hlcmUgd2UncmUgZXhwZWN0aW5nIHRvIGZpbmQgYSBkZWZpbmVkIG9iamVjdCAob3B0aW9uYWwpXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgaWYgaXQncyBub3QgdW5kZWZpbmVkLCBvdGhlcndpc2UgdGhyb3dzIGFuIGVycm9yXG4gKi9cbmV4cG9ydCBjb25zdCBleHBlY3ROb25OdWxsID0gPFQ+KHZhbHVlOiBUIHwgbnVsbCB8IHVuZGVmaW5lZCwgbG9jYXRpb24/OiBzdHJpbmcpOiBUID0+IHtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGEgbm9uLW51bGwgdmFsdWUgZm9yICR7bG9jYXRpb259YCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIG5vbi1udWxsIHZhbHVlXCIpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogQXNzZXJ0cyBhIHZhbHVlIGlzIGFuIEpTT04tbGlrZSBvYmplY3QgYW5kIHJldHVybnMgaXQuIFRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgdXNlZFxuICogd2l0aCB2YWx1ZXMgcGFyc2VkIGZyb20gSlNPTiAoYXJyYXlzLCBvYmplY3RzLCBudW1iZXJzLCBzdHJpbmdzLCBib29sZWFucykuXG4gKlxuICogQHBhcmFtIHZhbHVlIEEgdmFsdWUgdGhhdCBpcyBleHBlY3RlZCB0byBiZSBhbiBvYmplY3RcbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSBpZiBpdCdzIGFuIG9iamVjdCwgdW5kZWZpbmVkIGlmIGl0J3MgbnVsbC91bmRlZmluZWQsXG4gKiAgIG90aGVyd2lzZSBhbiBlcnJvciBpcyB0aHJvd24uXG4gKi9cbmV4cG9ydCBjb25zdCBleHBlY3RPYmplY3QgPSAodmFsdWU6IGFueSk6IHsgW2tleTogc3RyaW5nXTogYW55IH0gfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgb2JqZWN0LCBnb3QgJHt0eXBlb2YgdmFsdWV9YCk7XG59O1xuXG4vKipcbiAqIEFzc2VydHMgYSB2YWx1ZSBpcyBhIHN0cmluZyBhbmQgcmV0dXJucyBpdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgQSB2YWx1ZSB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGEgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIHZhbHVlIGlmIGl0J3MgYSBzdHJpbmcsIHVuZGVmaW5lZCBpZiBpdCdzIG51bGwvdW5kZWZpbmVkLFxuICogICBvdGhlcndpc2UgYW4gZXJyb3IgaXMgdGhyb3duLlxuICovXG5leHBvcnQgY29uc3QgZXhwZWN0U3RyaW5nID0gKHZhbHVlOiBhbnkpOiBzdHJpbmcgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiB2YWx1ZX1gKTtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgdmFsdWUgaW50byBhIGRvdWJsZS4gSWYgdGhlIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkLCB1bmRlZmluZWRcbiAqIHdpbGwgYmUgcmV0dXJuZWQuIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSBwYXJzZWQgYnkgdGhlIHN0YW5kYXJkXG4gKiBwYXJzZUZsb2F0IHdpdGggb25lIGV4Y2VwdGlvbjogTmFOIG1heSBvbmx5IGJlIGV4cGxpY2l0bHkgc2V0IGFzIHRoZSBzdHJpbmdcbiAqIFwiTmFOXCIsIGFueSBpbXBsaWNpdCBOYW4gdmFsdWVzIHdpbGwgcmVzdWx0IGluIGFuIGVycm9yIGJlaW5nIHRocm93bi4gSWYgYW55XG4gKiBvdGhlciB0eXBlIGlzIHByb3ZpZGVkLCBhbiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKlxuICogQHBhcmFtIHZhbHVlIEEgbnVtYmVyIG9yIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGRvdWJsZS5cbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSBhcyBhIG51bWJlciwgb3IgdW5kZWZpbmVkIGlmIGl0J3MgbnVsbC91bmRlZmluZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBzdHJpY3RQYXJzZURvdWJsZSA9ICh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGV4cGVjdE51bWJlcihwYXJzZU51bWJlcih2YWx1ZSkpO1xuICB9XG4gIHJldHVybiBleHBlY3ROdW1iZXIodmFsdWUpO1xufTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2Ugc3RyaWN0UGFyc2VEb3VibGVcbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmljdFBhcnNlRmxvYXQgPSBzdHJpY3RQYXJzZURvdWJsZTtcblxuLyoqXG4gKiBQYXJzZXMgYSB2YWx1ZSBpbnRvIGEgZmxvYXQuIElmIHRoZSB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZCwgdW5kZWZpbmVkXG4gKiB3aWxsIGJlIHJldHVybmVkLiBJZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIGl0IHdpbGwgYmUgcGFyc2VkIGJ5IHRoZSBzdGFuZGFyZFxuICogcGFyc2VGbG9hdCB3aXRoIG9uZSBleGNlcHRpb246IE5hTiBtYXkgb25seSBiZSBleHBsaWNpdGx5IHNldCBhcyB0aGUgc3RyaW5nXG4gKiBcIk5hTlwiLCBhbnkgaW1wbGljaXQgTmFuIHZhbHVlcyB3aWxsIHJlc3VsdCBpbiBhbiBlcnJvciBiZWluZyB0aHJvd24uIElmIGFueVxuICogb3RoZXIgdHlwZSBpcyBwcm92aWRlZCwgYW4gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBBIG51bWJlciBvciBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBmbG9hdC5cbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSBhcyBhIG51bWJlciwgb3IgdW5kZWZpbmVkIGlmIGl0J3MgbnVsbC91bmRlZmluZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBzdHJpY3RQYXJzZUZsb2F0MzIgPSAodmFsdWU6IHN0cmluZyB8IG51bWJlcik6IG51bWJlciB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBleHBlY3RGbG9hdDMyKHBhcnNlTnVtYmVyKHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdEZsb2F0MzIodmFsdWUpO1xufTtcblxuLy8gVGhpcyByZWdleCBtYXRjaGVzIEpTT04tc3R5bGUgbnVtYmVycy4gSW4gc2hvcnQ6XG4vLyAqIFRoZSBpbnRlZ3JhbCBtYXkgc3RhcnQgd2l0aCBhIG5lZ2F0aXZlIHNpZ24sIGJ1dCBub3QgYSBwb3NpdGl2ZSBvbmVcbi8vICogTm8gbGVhZGluZyAwIG9uIHRoZSBpbnRlZ3JhbCB1bmxlc3MgaXQncyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhICcuJ1xuLy8gKiBFeHBvbmVudCBpbmRpY2F0ZWQgYnkgYSBjYXNlLWluc2Vuc2l0aXZlICdFJyBvcHRpb25hbGx5IGZvbGxvd2VkIGJ5IGFcbi8vICAgcG9zaXRpdmUvbmVnYXRpdmUgc2lnbiBhbmQgc29tZSBudW1iZXIgb2YgZGlnaXRzLlxuLy8gSXQgYWxzbyBtYXRjaGVzIGJvdGggcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIGluZmluaXR5IGFzIHdlbGwgYW5kIGV4cGxpY2l0IE5hTi5cbmNvbnN0IE5VTUJFUl9SRUdFWCA9IC8oLT8oPzowfFsxLTldXFxkKikoPzpcXC5cXGQrKT8oPzpbZUVdWystXT9cXGQrKT8pfCgtP0luZmluaXR5KXwoTmFOKS9nO1xuXG5jb25zdCBwYXJzZU51bWJlciA9ICh2YWx1ZTogc3RyaW5nKTogbnVtYmVyID0+IHtcbiAgY29uc3QgbWF0Y2hlcyA9IHZhbHVlLm1hdGNoKE5VTUJFUl9SRUdFWCk7XG4gIGlmIChtYXRjaGVzID09PSBudWxsIHx8IG1hdGNoZXNbMF0ubGVuZ3RoICE9PSB2YWx1ZS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCByZWFsIG51bWJlciwgZ290IGltcGxpY2l0IE5hTmApO1xuICB9XG4gIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcbn07XG5cbi8qKlxuICogQXNzZXJ0cyBhIHZhbHVlIGlzIGEgbnVtYmVyIGFuZCByZXR1cm5zIGl0LiBJZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmdcbiAqIHJlcHJlc2VudGF0aW9uIG9mIGEgbm9uLW51bWVyaWMgbnVtYmVyIHR5cGUgKE5hTiwgSW5maW5pdHksIC1JbmZpbml0eSksXG4gKiB0aGUgdmFsdWUgd2lsbCBiZSBwYXJzZWQuIEFueSBvdGhlciBzdHJpbmcgdmFsdWUgd2lsbCByZXN1bHQgaW4gYW4gZXhjZXB0aW9uXG4gKiBiZWluZyB0aHJvd24uIE51bGwgb3IgdW5kZWZpbmVkIHdpbGwgYmUgcmV0dXJuZWQgYXMgdW5kZWZpbmVkLiBBbnkgb3RoZXJcbiAqIHR5cGUgd2lsbCByZXN1bHQgaW4gYW4gZXhjZXB0aW9uIGJlaW5nIHRocm93bi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgQSBudW1iZXIgb3Igc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbm9uLW51bWVyaWMgZmxvYXQuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgYXMgYSBudW1iZXIsIG9yIHVuZGVmaW5lZCBpZiBpdCdzIG51bGwvdW5kZWZpbmVkLlxuICovXG5leHBvcnQgY29uc3QgbGltaXRlZFBhcnNlRG91YmxlID0gKHZhbHVlOiBzdHJpbmcgfCBudW1iZXIpOiBudW1iZXIgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdFN0cmluZyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdE51bWJlcih2YWx1ZSk7XG59O1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBsaW1pdGVkUGFyc2VEb3VibGVcbiAqL1xuZXhwb3J0IGNvbnN0IGhhbmRsZUZsb2F0ID0gbGltaXRlZFBhcnNlRG91YmxlO1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBsaW1pdGVkUGFyc2VEb3VibGVcbiAqL1xuZXhwb3J0IGNvbnN0IGxpbWl0ZWRQYXJzZUZsb2F0ID0gbGltaXRlZFBhcnNlRG91YmxlO1xuXG4vKipcbiAqIEFzc2VydHMgYSB2YWx1ZSBpcyBhIDMyLWJpdCBmbG9hdCBhbmQgcmV0dXJucyBpdC4gSWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nXG4gKiByZXByZXNlbnRhdGlvbiBvZiBhIG5vbi1udW1lcmljIG51bWJlciB0eXBlIChOYU4sIEluZmluaXR5LCAtSW5maW5pdHkpLFxuICogdGhlIHZhbHVlIHdpbGwgYmUgcGFyc2VkLiBBbnkgb3RoZXIgc3RyaW5nIHZhbHVlIHdpbGwgcmVzdWx0IGluIGFuIGV4Y2VwdGlvblxuICogYmVpbmcgdGhyb3duLiBOdWxsIG9yIHVuZGVmaW5lZCB3aWxsIGJlIHJldHVybmVkIGFzIHVuZGVmaW5lZC4gQW55IG90aGVyXG4gKiB0eXBlIHdpbGwgcmVzdWx0IGluIGFuIGV4Y2VwdGlvbiBiZWluZyB0aHJvd24uXG4gKlxuICogQHBhcmFtIHZhbHVlIEEgbnVtYmVyIG9yIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG5vbi1udW1lcmljIGZsb2F0LlxuICogQHJldHVybnMgVGhlIHZhbHVlIGFzIGEgbnVtYmVyLCBvciB1bmRlZmluZWQgaWYgaXQncyBudWxsL3VuZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGxpbWl0ZWRQYXJzZUZsb2F0MzIgPSAodmFsdWU6IHN0cmluZyB8IG51bWJlcik6IG51bWJlciB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBwYXJzZUZsb2F0U3RyaW5nKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZXhwZWN0RmxvYXQzMih2YWx1ZSk7XG59O1xuXG5jb25zdCBwYXJzZUZsb2F0U3RyaW5nID0gKHZhbHVlOiBzdHJpbmcpOiBudW1iZXIgPT4ge1xuICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgY2FzZSBcIk5hTlwiOlxuICAgICAgcmV0dXJuIE5hTjtcbiAgICBjYXNlIFwiSW5maW5pdHlcIjpcbiAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICBjYXNlIFwiLUluZmluaXR5XCI6XG4gICAgICByZXR1cm4gLUluZmluaXR5O1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBwYXJzZSBmbG9hdCB2YWx1ZTogJHt2YWx1ZX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQYXJzZXMgYSB2YWx1ZSBpbnRvIGFuIGludGVnZXIuIElmIHRoZSB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZCwgdW5kZWZpbmVkXG4gKiB3aWxsIGJlIHJldHVybmVkLiBJZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIGl0IHdpbGwgYmUgcGFyc2VkIGJ5IHBhcnNlRmxvYXRcbiAqIGFuZCB0aGUgcmVzdWx0IHdpbGwgYmUgYXNzZXJ0ZWQgdG8gYmUgYW4gaW50ZWdlci4gSWYgdGhlIHBhcnNlZCB2YWx1ZSBpcyBub3RcbiAqIGFuIGludGVnZXIsIG9yIHRoZSByYXcgdmFsdWUgaXMgYW55IHR5cGUgb3RoZXIgdGhhbiBhIHN0cmluZyBvciBudW1iZXIsIGFuXG4gKiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKlxuICogQHBhcmFtIHZhbHVlIEEgbnVtYmVyIG9yIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLlxuICogQHJldHVybnMgVGhlIHZhbHVlIGFzIGEgbnVtYmVyLCBvciB1bmRlZmluZWQgaWYgaXQncyBudWxsL3VuZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmljdFBhcnNlTG9uZyA9ICh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIC8vIHBhcnNlSW50IGNhbid0IGJlIHVzZWQgaGVyZSwgYmVjYXVzZSBpdCB3aWxsIHNpbGVudGx5IGRpc2NhcmQgYW55XG4gICAgLy8gZXhpc3RpbmcgZGVjaW1hbHMuIFdlIHdhbnQgdG8gaW5zdGVhZCB0aHJvdyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgYW55LlxuICAgIHJldHVybiBleHBlY3RMb25nKHBhcnNlTnVtYmVyKHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdExvbmcodmFsdWUpO1xufTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2Ugc3RyaWN0UGFyc2VMb25nXG4gKi9cbmV4cG9ydCBjb25zdCBzdHJpY3RQYXJzZUludCA9IHN0cmljdFBhcnNlTG9uZztcblxuLyoqXG4gKiBQYXJzZXMgYSB2YWx1ZSBpbnRvIGEgMzItYml0IGludGVnZXIuIElmIHRoZSB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZCwgdW5kZWZpbmVkXG4gKiB3aWxsIGJlIHJldHVybmVkLiBJZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIGl0IHdpbGwgYmUgcGFyc2VkIGJ5IHBhcnNlRmxvYXRcbiAqIGFuZCB0aGUgcmVzdWx0IHdpbGwgYmUgYXNzZXJ0ZWQgdG8gYmUgYW4gaW50ZWdlci4gSWYgdGhlIHBhcnNlZCB2YWx1ZSBpcyBub3RcbiAqIGFuIGludGVnZXIsIG9yIHRoZSByYXcgdmFsdWUgaXMgYW55IHR5cGUgb3RoZXIgdGhhbiBhIHN0cmluZyBvciBudW1iZXIsIGFuXG4gKiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKlxuICogQHBhcmFtIHZhbHVlIEEgbnVtYmVyIG9yIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIDMyLWJpdCBpbnRlZ2VyLlxuICogQHJldHVybnMgVGhlIHZhbHVlIGFzIGEgbnVtYmVyLCBvciB1bmRlZmluZWQgaWYgaXQncyBudWxsL3VuZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmljdFBhcnNlSW50MzIgPSAodmFsdWU6IHN0cmluZyB8IG51bWJlcik6IG51bWJlciB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAvLyBwYXJzZUludCBjYW4ndCBiZSB1c2VkIGhlcmUsIGJlY2F1c2UgaXQgd2lsbCBzaWxlbnRseSBkaXNjYXJkIGFueVxuICAgIC8vIGV4aXN0aW5nIGRlY2ltYWxzLiBXZSB3YW50IHRvIGluc3RlYWQgdGhyb3cgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueS5cbiAgICByZXR1cm4gZXhwZWN0SW50MzIocGFyc2VOdW1iZXIodmFsdWUpKTtcbiAgfVxuICByZXR1cm4gZXhwZWN0SW50MzIodmFsdWUpO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYSB2YWx1ZSBpbnRvIGEgMTYtYml0IGludGVnZXIuIElmIHRoZSB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZCwgdW5kZWZpbmVkXG4gKiB3aWxsIGJlIHJldHVybmVkLiBJZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIGl0IHdpbGwgYmUgcGFyc2VkIGJ5IHBhcnNlRmxvYXRcbiAqIGFuZCB0aGUgcmVzdWx0IHdpbGwgYmUgYXNzZXJ0ZWQgdG8gYmUgYW4gaW50ZWdlci4gSWYgdGhlIHBhcnNlZCB2YWx1ZSBpcyBub3RcbiAqIGFuIGludGVnZXIsIG9yIHRoZSByYXcgdmFsdWUgaXMgYW55IHR5cGUgb3RoZXIgdGhhbiBhIHN0cmluZyBvciBudW1iZXIsIGFuXG4gKiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKlxuICogQHBhcmFtIHZhbHVlIEEgbnVtYmVyIG9yIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIDE2LWJpdCBpbnRlZ2VyLlxuICogQHJldHVybnMgVGhlIHZhbHVlIGFzIGEgbnVtYmVyLCBvciB1bmRlZmluZWQgaWYgaXQncyBudWxsL3VuZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmljdFBhcnNlU2hvcnQgPSAodmFsdWU6IHN0cmluZyB8IG51bWJlcik6IG51bWJlciB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAvLyBwYXJzZUludCBjYW4ndCBiZSB1c2VkIGhlcmUsIGJlY2F1c2UgaXQgd2lsbCBzaWxlbnRseSBkaXNjYXJkIGFueVxuICAgIC8vIGV4aXN0aW5nIGRlY2ltYWxzLiBXZSB3YW50IHRvIGluc3RlYWQgdGhyb3cgYW4gZXJyb3IgaWYgdGhlcmUgYXJlIGFueS5cbiAgICByZXR1cm4gZXhwZWN0U2hvcnQocGFyc2VOdW1iZXIodmFsdWUpKTtcbiAgfVxuICByZXR1cm4gZXhwZWN0U2hvcnQodmFsdWUpO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYSB2YWx1ZSBpbnRvIGFuIDgtYml0IGludGVnZXIuIElmIHRoZSB2YWx1ZSBpcyBudWxsIG9yIHVuZGVmaW5lZCwgdW5kZWZpbmVkXG4gKiB3aWxsIGJlIHJldHVybmVkLiBJZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIGl0IHdpbGwgYmUgcGFyc2VkIGJ5IHBhcnNlRmxvYXRcbiAqIGFuZCB0aGUgcmVzdWx0IHdpbGwgYmUgYXNzZXJ0ZWQgdG8gYmUgYW4gaW50ZWdlci4gSWYgdGhlIHBhcnNlZCB2YWx1ZSBpcyBub3RcbiAqIGFuIGludGVnZXIsIG9yIHRoZSByYXcgdmFsdWUgaXMgYW55IHR5cGUgb3RoZXIgdGhhbiBhIHN0cmluZyBvciBudW1iZXIsIGFuXG4gKiBleGNlcHRpb24gd2lsbCBiZSB0aHJvd24uXG4gKlxuICogQHBhcmFtIHZhbHVlIEEgbnVtYmVyIG9yIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbiA4LWJpdCBpbnRlZ2VyLlxuICogQHJldHVybnMgVGhlIHZhbHVlIGFzIGEgbnVtYmVyLCBvciB1bmRlZmluZWQgaWYgaXQncyBudWxsL3VuZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmljdFBhcnNlQnl0ZSA9ICh2YWx1ZTogc3RyaW5nIHwgbnVtYmVyKTogbnVtYmVyIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIC8vIHBhcnNlSW50IGNhbid0IGJlIHVzZWQgaGVyZSwgYmVjYXVzZSBpdCB3aWxsIHNpbGVudGx5IGRpc2NhcmQgYW55XG4gICAgLy8gZXhpc3RpbmcgZGVjaW1hbHMuIFdlIHdhbnQgdG8gaW5zdGVhZCB0aHJvdyBhbiBlcnJvciBpZiB0aGVyZSBhcmUgYW55LlxuICAgIHJldHVybiBleHBlY3RCeXRlKHBhcnNlTnVtYmVyKHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIGV4cGVjdEJ5dGUodmFsdWUpO1xufTtcbiJdfQ==